/************************************************************************************************
 * @file   i2c.c
 *
 * @brief  I2C Library Source Code
 *
 * @date   2024-11-29
 * @author Midnight Sun Team #24 - MSXVI
 ************************************************************************************************/

/* Standard library Headers */

/* Inter-component Headers */
#include "FreeRTOS.h"
#include "semphr.h"
#include "stm32l433xx.h"
#include "stm32l4xx_hal_conf.h"
#include "stm32l4xx_hal_i2c.h"
#include "stm32l4xx_hal_i2c_ex.h"
#include "stm32l4xx_hal_rcc.h"

/* Intra-component Headers */
#include "i2c.h"
#include "interrupts.h"

static inline void s_enable_i2c1(void) {
  __HAL_RCC_I2C1_CLK_ENABLE();
}
static inline void s_enable_i2c2(void) {
  __HAL_RCC_I2C2_CLK_ENABLE();
}

/** @brief  I2C Port data */
typedef struct {
  I2C_TypeDef *base;     /**< I2C HW Base address */
  void (*rcc_cmd)(void); /**< Function pointer to enable I2C clock using RCC */
  uint8_t ev_irqn;       /**< Event interrupt number */
  uint8_t err_irqn;      /**< Error interrupt number */
  bool initialized;      /**< Initialized flag */
} I2CPortData;

static I2CPortData s_port[NUM_I2C_PORTS] = {
  [I2C_PORT_1] = { .rcc_cmd = s_enable_i2c1, .base = I2C1, .ev_irqn = I2C1_EV_IRQn, .err_irqn = I2C1_ER_IRQn },
  [I2C_PORT_2] = { .rcc_cmd = s_enable_i2c2, .base = I2C2, .ev_irqn = I2C2_EV_IRQn, .err_irqn = I2C2_ER_IRQn },
};

/**
 * Autogenerated values from STM32CubeMX.
 * These can be calculated following ref manual pg 1024 for 80MHz APB1/2 Clock speed
 */
static uint32_t s_i2c_timing[NUM_I2C_SPEEDS] = {
  [I2C_SPEED_STANDARD] = 0x10909CECU,
  [I2C_SPEED_FAST] = 0x00702991U,
};

static I2C_HandleTypeDef s_i2c_handles[NUM_I2C_PORTS];

/* Mutex for port access */
static StaticSemaphore_t s_i2c_port_mutex[NUM_I2C_PORTS];
static SemaphoreHandle_t s_i2c_port_handle[NUM_I2C_PORTS];

/* Semaphore to signal event complete */
static StaticSemaphore_t s_i2c_cmplt_sem[NUM_I2C_PORTS];
static SemaphoreHandle_t s_i2c_cmplt_handle[NUM_I2C_PORTS];

/* Private helper for common TX/RX operations */
static StatusCode s_i2c_transfer(I2CPort i2c, I2CAddress addr, uint8_t *data, size_t len, bool is_rx) {
  if (data == NULL || i2c >= NUM_I2C_PORTS || len > I2C_MAX_NUM_DATA) {
    return STATUS_CODE_INVALID_ARGS;
  }

  if (!s_port[i2c].initialized) {
    return STATUS_CODE_UNINITIALIZED;
  }

  /* Take the mutex for this I2C port */
  if (xSemaphoreTake(s_i2c_port_handle[i2c], pdMS_TO_TICKS(I2C_TIMEOUT_MS)) != pdTRUE) {
    return STATUS_CODE_TIMEOUT;
  }

  HAL_StatusTypeDef status;
  if (is_rx) {
    status = HAL_I2C_Master_Receive_IT(&s_i2c_handles[i2c], addr << 1U, data, len);
  } else {
    status = HAL_I2C_Master_Transmit_IT(&s_i2c_handles[i2c], addr << 1U, data, len);
  }

  if (status != HAL_OK) {
    xSemaphoreGive(s_i2c_port_handle[i2c]);
    return STATUS_CODE_INTERNAL_ERROR;
  }

  if (xSemaphoreTake(s_i2c_cmplt_handle[i2c], pdMS_TO_TICKS(I2C_TIMEOUT_MS)) != pdTRUE) {
    xSemaphoreGive(s_i2c_port_handle[i2c]);
    return STATUS_CODE_TIMEOUT;
  }

  if (s_i2c_handles[i2c].ErrorCode != HAL_I2C_ERROR_NONE) {
    xSemaphoreGive(s_i2c_port_handle[i2c]);
    return STATUS_CODE_INTERNAL_ERROR;
  }

  xSemaphoreGive(s_i2c_port_handle[i2c]);
  return STATUS_CODE_OK;
}

/* Private helper to handle transfer complete */
static void s_i2c_transfer_complete_callback(I2C_HandleTypeDef *hi2c, bool is_rx) {
  BaseType_t higher_priority_task = pdFALSE;

  if (hi2c->Instance == I2C1) {
    xSemaphoreGiveFromISR(s_i2c_cmplt_handle[I2C_PORT_1], &higher_priority_task);
  } else {
    xSemaphoreGiveFromISR(s_i2c_cmplt_handle[I2C_PORT_2], &higher_priority_task);
  }
  portYIELD_FROM_ISR(higher_priority_task);
}

void I2C1_EV_IRQHandler(void) {
  HAL_I2C_EV_IRQHandler(&s_i2c_handles[I2C_PORT_1]);
}

void I2C1_ER_IRQHandler(void) {
  HAL_I2C_ER_IRQHandler(&s_i2c_handles[I2C_PORT_1]);
}

void I2C2_EV_IRQHandler(void) {
  HAL_I2C_EV_IRQHandler(&s_i2c_handles[I2C_PORT_2]);
}

void I2C2_ER_IRQHandler(void) {
  HAL_I2C_ER_IRQHandler(&s_i2c_handles[I2C_PORT_2]);
}

/* Callback functions for HAL I2C TX */
void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c) {
  s_i2c_transfer_complete_callback(hi2c, false);
}

/* Callback functions for HAL I2C RX */
void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c) {
  s_i2c_transfer_complete_callback(hi2c, true);
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c) {
  I2CPort i2c = NUM_I2C_PORTS;
  BaseType_t higher_priority_task = pdFALSE;

  if (hi2c->Instance == I2C1) {
    i2c = I2C_PORT_1;
  } else {
    i2c = I2C_PORT_2;
  }

  uint32_t error = HAL_I2C_GetError(hi2c);

  if (error & HAL_I2C_ERROR_BERR) {
    /* Future expansion */
  }

  if (error & HAL_I2C_ERROR_ARLO) {
    /* Future expansion */
  }

  if (error & HAL_I2C_ERROR_AF) {
    /* Future expansion */
  }

  if (error & HAL_I2C_ERROR_OVR) {
    /* Future expansion */
  }

  if (error & HAL_I2C_ERROR_DMA) {
    /* Future expansion */
  }

  /* Release the semaphores to prevent a deadlock where these are never returned from XFR complete */
  xSemaphoreGiveFromISR(s_i2c_cmplt_handle[i2c], &higher_priority_task);
  portYIELD_FROM_ISR(higher_priority_task);

  /* Soft reset */
  HAL_I2C_DeInit(hi2c);
  HAL_I2C_Init(hi2c);
}

StatusCode i2c_init(I2CPort i2c, const I2CSettings *settings) {
  if (settings == NULL) {
    return STATUS_CODE_INVALID_ARGS;
  }

  if (i2c >= NUM_I2C_PORTS) {
    return STATUS_CODE_INVALID_ARGS;
  }

  if (s_port[i2c].initialized) {
    return STATUS_CODE_RESOURCE_EXHAUSTED;
  }

  s_i2c_port_handle[i2c] = xSemaphoreCreateMutexStatic(&s_i2c_port_mutex[i2c]);
  s_i2c_cmplt_handle[i2c] = xSemaphoreCreateBinaryStatic(&s_i2c_cmplt_sem[i2c]);

  if (s_i2c_port_handle[i2c] == NULL || s_i2c_cmplt_handle[i2c] == NULL) {
    return STATUS_CODE_INTERNAL_ERROR;
  }

  /* The I2C pins need to be configured in push pull instead of Open drain mode. TODO: Research why */
  gpio_init_pin_af(&settings->sda, GPIO_ALTFN_PUSH_PULL, GPIO_ALT4_I2C1);
  gpio_init_pin_af(&settings->scl, GPIO_ALTFN_PUSH_PULL, GPIO_ALT4_I2C1);

  s_i2c_handles[i2c].Instance = s_port[i2c].base;
  s_i2c_handles[i2c].Init.Timing = s_i2c_timing[settings->speed];
  s_i2c_handles[i2c].Init.OwnAddress1 = 0U;
  s_i2c_handles[i2c].Init.OwnAddress2 = 0U;
  s_i2c_handles[i2c].Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  s_i2c_handles[i2c].Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  s_i2c_handles[i2c].Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  s_i2c_handles[i2c].Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  s_i2c_handles[i2c].Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;

  RCC_PeriphCLKInitTypeDef periph_clk_init = { 0U };

  if (i2c == I2C_PORT_1) {
    periph_clk_init.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
    periph_clk_init.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
  } else { /* I2C_PORT_2 */
    periph_clk_init.PeriphClockSelection = RCC_PERIPHCLK_I2C2;
    periph_clk_init.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
  }

  if (HAL_RCCEx_PeriphCLKConfig(&periph_clk_init) != HAL_OK) {
    return STATUS_CODE_INTERNAL_ERROR;
  }

  s_port[i2c].rcc_cmd();

  if (HAL_I2C_Init(&s_i2c_handles[i2c]) != HAL_OK) {
    return STATUS_CODE_INTERNAL_ERROR;
  }

  if (HAL_I2CEx_ConfigAnalogFilter(&s_i2c_handles[i2c], I2C_ANALOGFILTER_ENABLE) != HAL_OK) {
    return STATUS_CODE_INTERNAL_ERROR;
  }

  if (HAL_I2CEx_ConfigDigitalFilter(&s_i2c_handles[i2c], 0U) != HAL_OK) {
    return STATUS_CODE_INTERNAL_ERROR;
  }

  interrupt_nvic_enable(s_port[i2c].ev_irqn, INTERRUPT_PRIORITY_HIGH);
  interrupt_nvic_enable(s_port[i2c].err_irqn, INTERRUPT_PRIORITY_HIGH);

  s_port[i2c].initialized = true;

  return STATUS_CODE_OK;
}

StatusCode i2c_read(I2CPort i2c, I2CAddress addr, uint8_t *rx_data, size_t rx_len) {
  return s_i2c_transfer(i2c, addr, rx_data, rx_len, true);
}

StatusCode i2c_write(I2CPort i2c, I2CAddress addr, uint8_t *tx_data, size_t tx_len) {
  return s_i2c_transfer(i2c, addr, tx_data, tx_len, false);
}

StatusCode i2c_read_reg(I2CPort i2c, I2CAddress addr, uint8_t reg, uint8_t *rx_data, size_t rx_len) {
  status_ok_or_return(s_i2c_transfer(i2c, addr, &reg, 1, false));
  return s_i2c_transfer(i2c, addr, rx_data, rx_len, true);
}

StatusCode i2c_write_reg(I2CPort i2c, I2CAddress addr, uint8_t reg, uint8_t *tx_data, size_t tx_len) {
  uint8_t write_data[I2C_MAX_NUM_DATA] = { 0 };
  write_data[0] = reg;
  for (size_t i = 1; i < tx_len + 1; i++) {
    write_data[i] = tx_data[i - 1];
  }

  return s_i2c_transfer(i2c, addr, write_data, tx_len + 1U, false);
}
