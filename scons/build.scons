from scons.common import parse_config
from pathlib import Path
import os 

Import("VARS")

TARGET = VARS.get("TARGET")
PLATFORM = VARS.get("PLATFORM")
env = VARS.get("env")

# Clone the C env and clear C flags
cxx_env = env.Clone()
cxx_env['CCFLAGS'] = ['-DMS_PLATFORM_X86', '-D_GNU_SOURCE'] + (['-DMS_TEST'] if '-DMS_TEST' in env['CCFLAGS'] else [])
cxx_env['LINK'] = 'g++'

ROOT = Dir('#')

BUILD_DIR = ROOT.Dir('build').Dir(PLATFORM)
BIN_DIR = BUILD_DIR.Dir('bin')
OBJ_DIR = BUILD_DIR.Dir('obj')
TEST_DIR = BUILD_DIR.Dir('test')

PY_DIR = ROOT.Dir('py')
PROJ_DIR = ROOT.Dir('projects')
LIB_DIR = ROOT.Dir('libraries')
SMOKE_DIR = ROOT.Dir('smoke')

LIB_BIN_DIR = BIN_DIR.Dir('libraries')
LIB_OBJ_DIR = OBJ_DIR.Dir('libraries')
LIBRARIES_INC_DIR = LIB_DIR.Dir("ms-common").Dir("inc")

AUTOGEN_DIR = ROOT.Dir("autogen")

def src(path):
    # return all source files within a path
    srcs = []
    for file in path.glob("src/*.[cs]") + path.glob("src/*.cc") + path.glob("src/*.cpp") + \
               path.glob(f"src/{PLATFORM}/*.[cs]") + path.glob(f"src/{PLATFORM}/*.cc") + path.glob(f"src/{PLATFORM}/*.cpp"):
        if file.abspath.startswith(OBJ_DIR.abspath):
            srcs.append(file)
        else:
            srcs.append(OBJ_DIR.File(file.path))
    return srcs

def inc(path):
    # return all include directories within a path
    return [path.Dir("inc"), path.Dir("inc").Dir(PLATFORM)]


def get_lib_deps(entry):
    # Recursively get library dependencies for entry
    config = parse_config(entry)
    deps = config['libs'] + config['{}_libs'.format(PLATFORM)]
    for dep in deps:
        deps += get_lib_deps(LIB_DIR.Dir(dep))
    return deps

###########################################################
# Header file generation from jinja templates
###########################################################
autogen_sources = list(Path(AUTOGEN_DIR.abspath).rglob("*"))
autogen_sources += list(Path(ROOT.abspath).glob("can/boards/*"))

AlwaysBuild(env.Command(
    LIBRARIES_INC_DIR.File("system_can.h"),
    autogen_sources,
    f"python3 -m autogen system_can -o can/inc"
))

AlwaysBuild(env.Command(
    ROOT.Dir("mpxe").Dir("server").Dir("app").Dir("inc").File("system_can.h"),
    None,
    f"python3 -m autogen system_can -o mpxe/server/app/inc"
))

AlwaysBuild(env.Command(
    None,
    None,
    f"python3 -m autogen simulation_app -o mpxe/server/app"
))

def generate_can_files(env, project):
    project_can_dir = OBJ_DIR.Dir(project).Dir("can")
    output_files = []

    project_name = Path(project).stem
    can_template_dir = Path(str(AUTOGEN_DIR), "templates/project_can")
    for template in can_template_dir.glob('*/*.jinja'):
        template_path = template.relative_to(can_template_dir)
        output_name = str(template_path) \
            .replace(r"{{project_name}}", project_name) \
            .replace(".jinja", "")

        output_files.append(project_can_dir.File(output_name))

    env.Command(output_files, autogen_sources,
                f"python3 -m autogen project_can -o {project_can_dir.path}")

    # Add a VariantDir that point to can folder. Create the can target specific for the project
    VariantDir(project_can_dir, ROOT.Dir('can'), duplicate=0)
    return src(project_can_dir), [project_can_dir.Dir("inc")] + inc(ROOT.Dir("can"))


###########################################################
# Library Build Functions
###########################################################

# Dictionary to store all library targets
library_targets = {}

# Include all library headers
lib_incs = [inc(lib_dir) for lib_dir in LIB_DIR.glob('*')]

def build_library(library_name, dependencies=None):
    # Skip if already built
    if library_name in library_targets:
        return library_targets[library_name]
    
    print(f"Building library: {library_name}")
    
    entry = LIB_DIR.Dir(library_name)
    config = parse_config(entry)

    # Get dependencies and build them first
    lib_deps = []
    if dependencies:
        lib_deps = dependencies
    else:
        lib_deps = get_lib_deps(entry)

    # Build all dependencies first
    dep_targets = []
    for dep in lib_deps:
        if dep not in library_targets and LIB_DIR.Dir(dep).exists():
            dep_target = build_library(dep)
            dep_targets.append(dep_target)

    # Build this library
    target = env.Library(
        target=LIB_BIN_DIR.File(f'lib{entry.name}.a'),
        source=src(entry),
        LIBS=env['LIBS'] + lib_deps * 2,
        LIBPATH=[LIB_BIN_DIR],
        CPPPATH=env['CPPPATH'] + lib_incs,
        CCFLAGS=env['CCFLAGS'] + config.get('cflags', [])
    )

    # Register the target
    library_targets[library_name] = target

    # Create aliases
    Alias(entry.path, target)
    Alias(entry.name, target)

    return target

def build_ms_mpxe_library():
    if 'ms-common' not in library_targets:
        build_library('ms-common')
    if 'ms-drivers' not in library_targets:
        build_library('ms-drivers')
    ms_mpxe_dir = ROOT.Dir("libraries").Dir("ms-mpxe")
    ms_mpxe_dir_src = ms_mpxe_dir.Dir("src")
    ms_mpxe_dir_inc = ms_mpxe_dir.Dir("inc")

    # Get MPXE client and common include paths
    mpxe_dir = ROOT.Dir("mpxe")
    mpxe_common_dir = mpxe_dir.Dir("common")
    mpxe_client_dir = mpxe_dir.Dir("client")
    mpxe_client_util_dir = mpxe_client_dir.Dir("utils")
    mpxe_client_app_dir = mpxe_client_dir.Dir("app")
    
    # Include paths
    include_paths = inc(ms_mpxe_dir) + inc(mpxe_common_dir) + inc(mpxe_client_util_dir) + inc(mpxe_client_app_dir)

    # Separate C and C++ sources
    c_sources = [file for file in Glob(str(ms_mpxe_dir_src) + "/*.c")]
    cpp_sources = [file for file in Glob(str(ms_mpxe_dir_src) + "/*.cc") + Glob(str(ms_mpxe_dir_src) + "/*.cpp")]

    # C object files with C compiler
    c_objects = [
        env.Object(
            target = LIB_OBJ_DIR.Dir("ms-mpxe").File(f'{Path(src.name).stem}.o'),
            source=src,
            CPPPATH=include_paths + env['CPPPATH']
        ) for src in c_sources
    ]
    
    # C++ object files with C++ compiler
    cpp_objects = [
        cxx_env.Object(
            target = LIB_OBJ_DIR.Dir("ms-mpxe").File(f'{Path(src.name).stem}.o'),
            source=src,
            CPPPATH=include_paths + env['CPPPATH']
        ) for src in cpp_sources
    ]

    # Combine all objects
    all_objects = c_objects + cpp_objects

    # Create the library
    ms_mpxe_lib = env.Library(
        target=LIB_BIN_DIR.File('libms-mpxe.a'),
        source=all_objects,
        LIBS=env['LIBS'],
        LIBPATH=[LIB_BIN_DIR],
        CPPPATH=env['CPPPATH'] + include_paths
    )

    # Register the target
    library_targets['ms-mpxe'] = ms_mpxe_lib
    Alias('ms-mpxe', ms_mpxe_lib)

    return ms_mpxe_lib

###########################################################
# MPXE Library Generation
###########################################################

def create_mpxe_common_lib():
    mpxe_dir = ROOT.Dir("mpxe")
    mpxe_common_dir = mpxe_dir.Dir("common")

    # Convert Path objects to SCons File nodes
    common_srcs = src(mpxe_common_dir)
    common_incs = inc(mpxe_common_dir)

    # Create the common library
    common_lib = cxx_env.Library(
        target=LIB_BIN_DIR.File('libmpxe_common.a'),
        source=common_srcs,
        LIBS=env['LIBS'],
        LIBPATH=[LIB_BIN_DIR],
        CPPPATH=env['CPPPATH'] + common_incs,
        CXXFLAGS=env['CXXFLAGS'],
    )

    # Register the target
    library_targets['mpxe_common'] = common_lib

    # Create alias
    Alias('mpxe_common', common_lib)

    return common_lib

def create_mpxe_client_lib():
    if 'ms-common' not in library_targets:
        build_library('ms-common')
    if 'ms-drivers' not in library_targets:
        build_library('ms-drivers')
    if 'mpxe_common' not in library_targets:
        create_mpxe_common_lib()

    mpxe_dir = ROOT.Dir("mpxe")
    mpxe_client_dir = mpxe_dir.Dir("client")
    mpxe_client_util_dir = mpxe_client_dir.Dir("utils")
    mpxe_client_app_dir = mpxe_client_dir.Dir("app")
    mpxe_common_dir = mpxe_dir.Dir("common")

    # Convert Path objects to SCons File nodes
    client_srcs = []
    client_srcs += src(mpxe_client_util_dir)
    client_srcs += src(mpxe_client_app_dir)

    client_incs = []
    client_incs += inc(mpxe_client_util_dir)
    client_incs += inc(mpxe_client_app_dir)
    client_incs += inc(mpxe_common_dir)
    client_incs += inc(LIB_DIR.Dir("ms-common"))
    client_incs += inc(LIB_DIR.Dir("ms-drivers"))

    # Create the client library
    client_lib = cxx_env.Library(
        target=LIB_BIN_DIR.File('libmpxe_client.a'),
        source=client_srcs,
        LIBS=env['LIBS'] + ['mpxe_common', 'ms-common', 'ms-drivers'],
        LIBPATH=[LIB_BIN_DIR],
        CPPPATH=env['CPPPATH'] + client_incs,
        CXXFLAGS=env['CXXFLAGS'],
    )

    # Register the target
    library_targets['mpxe_client'] = client_lib

    # Create alias
    Alias('mpxe_client', client_lib)

    return client_lib

def create_mpxe_server():
    if 'mpxe_common' not in library_targets:
        create_mpxe_common_lib()

    mpxe_dir = ROOT.Dir("mpxe")
    mpxe_server_dir = mpxe_dir.Dir("server")
    mpxe_server_util_dir = mpxe_server_dir.Dir("utils")
    mpxe_server_app_dir = mpxe_server_dir.Dir("app")
    mpxe_common_dir = mpxe_dir.Dir("common")

    # Convert Path objects to SCons File nodes
    server_srcs = []
    server_srcs += src(mpxe_server_util_dir)
    server_srcs += src(mpxe_server_app_dir)

    server_incs = []
    server_incs += inc(mpxe_server_util_dir)
    server_incs += inc(mpxe_server_app_dir)
    server_incs += inc(mpxe_common_dir)
    server_incs += inc(LIB_DIR.Dir("ms-common"))
    server_incs += inc(LIB_DIR.Dir("ms-drivers"))

    # Create the client library
    server_exe = cxx_env.Program(
        target=BIN_DIR.Dir('projects').File('mpxe_server'),
        source=server_srcs,
        CPPPATH=cxx_env['CPPPATH'] + server_incs,
        LIBS=env['LIBS'] + ['mpxe_common'] * 2,
        LIBPATH=[LIB_BIN_DIR],
        CXXFLAGS=env['CXXFLAGS'],
    )

    Default(server_exe)

    # Register the target
    library_targets['mpxe_server'] = server_exe

    # Create alias
    Alias('mpxe_server', server_exe)

    return server_exe

###########################################################
# Build Process
###########################################################

# 1. Build ms-common first
ms_common_lib = build_library('ms-common')
ms_drivers_lib = build_library('ms-drivers')

# 2. Build all other non-MPXE libraries
for entry in LIB_DIR.glob('*'):
    if entry.name not in ['ms-common', 'ms-mpxe', 'ms-drivers']:
        build_library(entry.name)
    
# 3. Build MPXE common and client libraries
mpxe_common_lib = create_mpxe_common_lib()
mpxe_client_lib = create_mpxe_client_lib()

# 4. Build ms-mpxe last, with explicit dependencies on MPXE libs
if LIB_DIR.Dir('ms-mpxe').exists():
    ms_mpxe_lib = build_ms_mpxe_library()

###########################################################
# Create appropriate targets for all projects and smoke projects
###########################################################
for entry in PROJ_DIR.glob('*') + SMOKE_DIR.glob('*'):
    config = parse_config(entry)

    incs = inc(entry)
    srcs = src(entry)

    if config["can"]:
        # Add Autogenerated files
        can_sources, can_headers = generate_can_files(env, entry.path)
        srcs += can_sources
        incs += can_headers

    incs += map(ROOT.Dir, config.get("include", []))
    srcs += map(OBJ_DIR.File, config.get("sources", []))

    lib_deps = get_lib_deps(entry)

    build_env = env
    if 'ms-mpxe' in lib_deps:
        lib_deps += ['mpxe_common', 'mpxe_client']
        build_env = cxx_env

    cppflags, ldflags = [], []
    if PLATFORM == "x86" and "SDL2" in lib_deps:
        import subprocess, shlex
        cppflags = shlex.split(subprocess.check_output(["pkg-config", "--cflags", "sdl2"]).decode())
        ldflags  = shlex.split(subprocess.check_output(["pkg-config", "--libs", "sdl2"]).decode())

    # SCons automagically handles object creation and linking
    if PLATFORM == 'x86' and config['arm_only']:
        print(f'Project: {entry} is only for ARM devices. Cannot build x86 version.')
    else:
        target = build_env.Program(
            target=BIN_DIR.File(entry.path),
            source=srcs,
            CPPPATH=build_env['CPPPATH'] + incs + lib_incs,
            # link each library twice so that dependency cycles are resolved
            # See: https://stackoverflow.com/questions/45135
            LIBS=build_env['LIBS'] + lib_deps * 2,
            LIBPATH=[LIB_BIN_DIR],
            CCFLAGS=build_env['CCFLAGS'] + config['cflags'],
            CXXFLAGS=build_env.get('CXXFLAGS', []) + cppflags,
            LINKFLAGS=build_env.get('LINKFLAGS', []) + ldflags,
        )

    # .bin file only required for arm, not x86
    if PLATFORM == 'arm':
        target = env.Bin(target=BIN_DIR.File(entry.path + '.bin'),
                         source=target)
    

    # Create an alias for the entry so we can do `scons leds` and it Just Works
    Alias(entry.path, target)
    Alias(entry.name, target)

if PLATFORM == 'x86':
    create_mpxe_server()

###########################################################
# MPXE GUI BUILD
###########################################################
qt6dir = os.environ.get("QT6DIR", "/usr/lib/qt6")
qtEnv = cxx_env.Clone(QT6DIR=qt6dir, tools=['gui_build_tool'], toolpath=['#scons'])
qtEnv.EnableQt6Modules(['QtCore', 'QtGui', 'QtWidgets'])
qtEnv.ParseConfig('pkg-config --cflags --libs Qt6Core Qt6Gui Qt6Widgets')
qtEnv['QT6_MOCCPPPATH'] = qtEnv['CPPPATH']

GUI_SRC = ROOT.Dir('mpxe').Dir('server').Dir('app').Dir('gui')
GUI_OBJ = OBJ_DIR.Dir('mpxe_gui')
VariantDir(GUI_OBJ, GUI_SRC, duplicate=0)

def collect_variant(src_root, var_root, patterns):
    """Return VARIANT File nodes for sources under src_root matching patterns."""
    base = Path(src_root.abspath)
    out = []
    for pat in patterns:
        for p in base.rglob(pat):
            if not p.is_file():
                continue
            sp = str(p)
            rel = str(Path(sp).relative_to(base))
            out.append(var_root.File(rel))
    # de-dup while preserving order
    return list(dict.fromkeys(out))

gui_cc = collect_variant(GUI_SRC, GUI_OBJ, ('*.cc', '*.cpp'))

# Keep main.cc first if present
main_src = GUI_OBJ.File('main.cc')
if main_src in gui_cc:
    gui_cc = [main_src] + [n for n in gui_cc if n is not main_src]

# Includes: variant (generated) + source (handwritten)
qtEnv.Append(CPPPATH=[
    GUI_OBJ.Dir('utils').Dir('inc'),
    GUI_OBJ.Dir('models').Dir('inc'),
    GUI_OBJ.Dir('ui').Dir('inc'),
    GUI_SRC.Dir('utils').Dir('inc'),
    GUI_SRC.Dir('models').Dir('inc'),
    GUI_SRC.Dir('ui').Dir('inc'),
])

mpxe_gui = qtEnv.Program(
    target=BIN_DIR.Dir('projects').File('mpxe_gui'),
    source=gui_cc
)
Alias('mpxe_gui', mpxe_gui)

###########################################################
# Python
###########################################################
for entry in PY_DIR.glob("*", exclude=["*.*", "__pycache__"]):
    target = env.Command(entry.path, [],
                         f"PYTHONPATH={PY_DIR.path} python3 {entry.path}/main.py")
    config = parse_config(entry)
    if config["can"]:
        # Depends(target, PY_DIR.File("can/message.py"))
        pass
    Alias(entry.path, target)
    Alias(entry.name, target)

# Build all projects when you just run `scons`
Default(TARGET or [e.path for e in PROJ_DIR.glob('*')])
