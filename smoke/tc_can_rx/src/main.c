/************************************************************************************************
 * @file   main.c
 *
 * @brief  Smoke test for Telemetry Board CAN RX
 *
 * @date   2025-10-02
 * @author Midnight Sun Team #24 - MSXVI
 ************************************************************************************************/

/* Standard library Headers */

/* Inter-component Headers */
#include "delay.h"
#include "ff.h"
#include "gpio.h"
#include "log.h"
#include "mcu.h"
#include "status.h"
#include "system_can.h"
#include "tasks.h"

/* Intra-component Headers */
#include "datagram.h"
#include "global_enums.h"
#include "telemetry.h"
#include "telemetry_hw_defs.h"

static TelemetryStorage *telemetry_storage;

static TelemetryConfig s_telemetry_config = {
  .uart_port = UART_PORT_2,
  .uart_settings = {
    .baudrate = 115200,
  },
  .message_transmit_frequency_hz = 10U,
};

static CanStorage s_can_storage = { 0 };

static const CanSettings s_can_settings = {
  .device_id = SYSTEM_CAN_DEVICE_TELEMETRY,
  .bitrate = CAN_HW_BITRATE_500KBPS,
  .tx = GPIO_TELEMETRY_CAN_TX,
  .rx = GPIO_TELEMETRY_CAN_RX,
  .loopback = false,
  .can_rx_all_cb = NULL,
};

#define RC_TRIG_BPS_FAULT_MASK 0x07FFu            // bits [10:0]
#define RC_TRIG_RELAY_STATE_BIT 11u               // bit 11
#define RC_TRIG_POWER_STATE_BIT 12u               // bit 12
#define RC_TRIG_AFE_STATUS_BIT 13u                // bit 13
#define RC_TRIG_MOTOR_PRECHARGE_COMPLETE_BIT 14u  // bit 14

/*< Rear controller TX struct - autogenerated and taken from build\arm\obj\projects\rear_controller\can\inc\rear_controller_tx_structs.h */
typedef struct {
  uint8_t rear_controller_status_triggers;
  /**< Unpacked bitfield -  rear_controller_status_triggers*/
  uint16_t bps_fault;
  uint8_t relay_state;
  uint8_t power_state;
  uint8_t afe_status;
  uint8_t motor_precharge_complete;
  /**> */
  uint16_t battery_stats_A_pack_voltage;
  uint16_t battery_stats_A_pack_current;
  uint16_t battery_stats_A_pack_soc;
  uint16_t battery_stats_B_max_cell_voltage;
  uint16_t battery_stats_B_min_cell_voltage;
  uint16_t battery_stats_B_max_temperature;
  uint16_t power_input_stats_input_dcdc_voltage;
  uint16_t power_input_stats_input_dcdc_current;
  uint16_t power_input_stats_input_aux_voltage;
  uint16_t power_input_stats_input_aux_current;
  uint8_t AFE1_status_A_id;
  uint16_t AFE1_status_A_voltage_0;
  uint16_t AFE1_status_A_voltage_1;
  uint16_t AFE1_status_A_voltage_2;
  uint8_t AFE1_status_B_id;
  uint16_t AFE1_status_B_voltage_0;
  uint16_t AFE1_status_B_voltage_1;
  uint16_t AFE1_status_B_voltage_2;
  uint8_t AFE2_status_A_id;
  uint16_t AFE2_status_A_voltage_0;
  uint16_t AFE2_status_A_voltage_1;
  uint16_t AFE2_status_A_voltage_2;
  uint8_t AFE2_status_B_id;
  uint16_t AFE2_status_B_voltage_0;
  uint16_t AFE2_status_B_voltage_1;
  uint16_t AFE2_status_B_voltage_2;
  uint8_t AFE_temperature_id;
  uint8_t AFE_temperature_temperature_0;
  uint8_t AFE_temperature_temperature_1;
  uint8_t AFE_temperature_temperature_2;
  uint8_t AFE_temperature_temperature_3;
  uint8_t AFE_temperature_temperature_4;
  uint8_t AFE_temperature_temperature_5;
  uint8_t AFE_temperature_temperature_6;
} rear_controller_tx_struct;

#define PEDAL_DATA_DRIVE_STATE_MASK 0x07u  // bits [2:0]
#define PEDAL_DATA_BRAKE_ENABLED_BIT 3u    // bit 3
#define PEDAL_DATA_REGEN_ENABLED_BIT 4u    // bit 4

/*< Front controller TX struct - autogenerated and taken from build\arm\obj\projects\front_controller\can\inc\front_controller_tx_structs.h */
typedef struct {
  uint32_t pedal_percentage;
  uint8_t pedal_data;
  /**< Unpacked bitfield - pedal_data*/
  uint8_t drive_state;
  bool brake_enabled;
  bool regen_enabled;
  /**> */
  uint32_t motor_velocity_vehicle_velocity;
  uint32_t motor_velocity_motor_velocity;
  uint32_t motor_temperature_heat_sink_temp;
  uint32_t motor_temperature_motor_temp;
  uint16_t fc_power_group_A_rev_cam_current;
  uint16_t fc_power_group_A_telem_current;
  uint16_t fc_power_group_A_steering_current;
  uint16_t fc_power_group_A_driver_fan_current;
  uint16_t fc_power_group_B_horn_current;
  uint16_t fc_power_group_B_spare_current;
  uint16_t fc_power_lights_group_brake_light_sig_current;
  uint16_t fc_power_lights_group_bps_light_sig_current;
  uint16_t fc_power_lights_group_right_sig_current;
  uint16_t fc_power_lights_group_left_sig_current;
} front_controller_tx_struct;

#define STEER_BTN_DRIVE_STATE_MASK 0x03u  // bits [1:0]
#define STEER_BTN_LIGHTS_MASK 0x0Cu       // bits [3:2]
#define STEER_BTN_LIGHTS_SHIFT 2u
#define STEER_BTN_CRUISE_ENABLED_BIT 4u  // bit 4
#define STEER_BTN_HAZARD_ENABLED_BIT 5u  // bit 5
#define STEER_BTN_HORN_ENABLED_BIT 6u    // bit 6
#define STEER_BTN_REGEN_ENABLED_BIT 7u   // bit 7

/*< Steering TX struct - autogenerated and taken from build\arm\obj\projects\steering\can\inc\steering_tx_structs.h */
typedef struct {
  uint32_t steering_cruise_control_target_velocity;
  uint8_t steering_buttons;
  /**< Unpacked bitfield - steering_buttons*/
  uint8_t drive_state;
  uint8_t lights;
  bool cruise_control_enabled;
  bool hazard_enabled;
  bool horn_enabled;
  bool regen_enabled;
  /**> */
} steering_tx_struct;

static front_controller_tx_struct s_front_controller_tx_struct = { 0 };
static rear_controller_tx_struct s_rear_controller_tx_struct = { 0 };
static steering_tx_struct s_steering_tx_struct = { 0 };

static const char *s_drive_state_strings[] = {
  [VEHICLE_DRIVE_STATE_INVALID] = "INVALID", [VEHICLE_DRIVE_STATE_NEUTRAL] = "NEUTRAL", [VEHICLE_DRIVE_STATE_DRIVE] = "DRIVE", [VEHICLE_DRIVE_STATE_REVERSE] = "REVERSE",
  [VEHICLE_DRIVE_STATE_CRUISE] = "CRUISE",   [VEHICLE_DRIVE_STATE_BRAKE] = "BRAKE",     [VEHICLE_DRIVE_STATE_REGEN] = "REGEN",
};

static const char *s_power_state_strings[] = {
  [VEHICLE_POWER_STATE_IDLE] = "IDLE",
  [VEHICLE_POWER_STATE_DRIVE] = "DRIVE",
  [VEHICLE_POWER_STATE_CHARGE] = "CHARGE",
  [VEHICLE_POWER_STATE_FAULT] = "FAULT",
};

static const char *s_bps_fault_strings[] = {
  [BPS_FAULT_OVERVOLTAGE] = "OVERVOLTAGE",
  [BPS_FAULT_UNBALANCE] = "UNBALANCE",
  [BPS_FAULT_OVERTEMP_AMBIENT] = "OVERTEMP_AMBIENT",
  [BPS_FAULT_COMMS_LOSS_AFE] = "COMMS_LOSS_AFE",
  [BPS_FAULT_COMMS_LOSS_CURR_SENSE] = "COMMS_LOSS_CURR_SENSE",
  [BPS_FAULT_OVERTEMP_CELL] = "OVERTEMP_CELL",
  [BPS_FAULT_OVERCURRENT] = "OVERCURRENT",
  [BPS_FAULT_UNDERVOLTAGE] = "UNDERVOLTAGE",
  [BPS_FAULT_KILLSWITCH] = "KILLSWITCH",
  [BPS_FAULT_RELAY_CLOSE_FAILED] = "RELAY_CLOSE_FAILED",
  [BPS_FAULT_DISCONNECTED] = "DISCONNECTED",
};

static void print_front_controller(const front_controller_tx_struct *data) {
  LOG_DEBUG("  [FRONT CONTROLLER]\r\n");
  LOG_DEBUG("    Pedal %%:             %lu\r\n", (uint32_t)data->pedal_percentage);
  LOG_DEBUG("    Pedal Data (raw):     0x%02X\r\n", (uint16_t)data->pedal_data);

  LOG_DEBUG("    Vehicle Vel:          %lu\r\n", (uint32_t)data->motor_velocity_vehicle_velocity);
  LOG_DEBUG("    Motor Vel:            %lu\r\n", (uint32_t)data->motor_velocity_motor_velocity);

  LOG_DEBUG("    Heatsink Temp:        %lu\r\n", (uint32_t)data->motor_temperature_heat_sink_temp);
  LOG_DEBUG("    Motor Temp:           %lu\r\n", (uint32_t)data->motor_temperature_motor_temp);

  LOG_DEBUG("    RevCam mA:            %u\r\n", data->fc_power_group_A_rev_cam_current);
  LOG_DEBUG("    Telem mA:             %u\r\n", data->fc_power_group_A_telem_current);
  LOG_DEBUG("    Steering mA:          %u\r\n", data->fc_power_group_A_steering_current);
  LOG_DEBUG("    Driver Fan mA:        %u\r\n", data->fc_power_group_A_driver_fan_current);

  LOG_DEBUG("    Horn mA:              %u\r\n", data->fc_power_group_B_horn_current);
  LOG_DEBUG("    Spare mA:             %u\r\n", data->fc_power_group_B_spare_current);

  LOG_DEBUG("    Brake Light mA:       %u\r\n", data->fc_power_lights_group_brake_light_sig_current);
  LOG_DEBUG("    BPS Light mA:         %u\r\n", data->fc_power_lights_group_bps_light_sig_current);
  LOG_DEBUG("    Right Sig mA:         %u\r\n", data->fc_power_lights_group_right_sig_current);
  LOG_DEBUG("    Left Sig mA:          %u\r\n", data->fc_power_lights_group_left_sig_current);
}

static void print_rear_controller(const rear_controller_tx_struct *data) {
  LOG_DEBUG("  [REAR CONTROLLER]\r\n");

  LOG_DEBUG("    Status Triggers:      0x%02X\r\n", (unsigned)data->rear_controller_status_triggers);

  LOG_DEBUG("    Pack Voltage:         %u mV\r\n", data->battery_stats_A_pack_voltage);
  LOG_DEBUG("    Pack Current:         %u mA\r\n", data->battery_stats_A_pack_current);
  LOG_DEBUG("    Pack SOC:             %u %%\r\n", data->battery_stats_A_pack_soc);

  LOG_DEBUG("    Max Cell V:           %u mV\r\n", data->battery_stats_B_max_cell_voltage);
  LOG_DEBUG("    Min Cell V:           %u mV\r\n", data->battery_stats_B_min_cell_voltage);
  LOG_DEBUG("    Max Temp:             %u\r\n", data->battery_stats_B_max_temperature);

  LOG_DEBUG("    DCDC Voltage:         %u mV\r\n", data->power_input_stats_input_dcdc_voltage);
  LOG_DEBUG("    DCDC Current:         %u mA\r\n", data->power_input_stats_input_dcdc_current);
  LOG_DEBUG("    AUX Voltage:          %u mV\r\n", data->power_input_stats_input_aux_voltage);
  LOG_DEBUG("    AUX Current:          %u mA\r\n", data->power_input_stats_input_aux_current);

  LOG_DEBUG("    AFE1 A ID:            %u\r\n", data->AFE1_status_A_id);
  LOG_DEBUG("      Cell V0:            %u mV\r\n", data->AFE1_status_A_voltage_0);
  LOG_DEBUG("      Cell V1:            %u mV\r\n", data->AFE1_status_A_voltage_1);
  LOG_DEBUG("      Cell V2:            %u mV\r\n", data->AFE1_status_A_voltage_2);

  LOG_DEBUG("    AFE1 B ID:            %u\r\n", data->AFE1_status_B_id);
  LOG_DEBUG("      Cell V0:            %u mV\r\n", data->AFE1_status_B_voltage_0);
  LOG_DEBUG("      Cell V1:            %u mV\r\n", data->AFE1_status_B_voltage_1);
  LOG_DEBUG("      Cell V2:            %u mV\r\n", data->AFE1_status_B_voltage_2);

  LOG_DEBUG("    AFE2 A ID:            %u\r\n", data->AFE2_status_A_id);
  LOG_DEBUG("      Cell V0:            %u mV\r\n", data->AFE2_status_A_voltage_0);
  LOG_DEBUG("      Cell V1:            %u mV\r\n", data->AFE2_status_A_voltage_1);
  LOG_DEBUG("      Cell V2:            %u mV\r\n", data->AFE2_status_A_voltage_2);

  LOG_DEBUG("    AFE2 B ID:            %u\r\n", data->AFE2_status_B_id);
  LOG_DEBUG("      Cell V0:            %u mV\r\n", data->AFE2_status_B_voltage_0);
  LOG_DEBUG("      Cell V1:            %u mV\r\n", data->AFE2_status_B_voltage_1);
  LOG_DEBUG("      Cell V2:            %u mV\r\n", data->AFE2_status_B_voltage_2);

  LOG_DEBUG("    AFE Temp ID:          %u\r\n", data->AFE_temperature_id);
  LOG_DEBUG("      T0:                 %u\r\n", data->AFE_temperature_temperature_0);
  LOG_DEBUG("      T1:                 %u\r\n", data->AFE_temperature_temperature_1);
  LOG_DEBUG("      T2:                 %u\r\n", data->AFE_temperature_temperature_2);
  LOG_DEBUG("      T3:                 %u\r\n", data->AFE_temperature_temperature_3);
  LOG_DEBUG("      T4:                 %u\r\n", data->AFE_temperature_temperature_4);
  LOG_DEBUG("      T5:                 %u\r\n", data->AFE_temperature_temperature_5);
  LOG_DEBUG("      T6:                 %u\r\n", data->AFE_temperature_temperature_6);
}

static void print_steering(const steering_tx_struct *data) {
  LOG_DEBUG("  [STEERING]\r\n");
  LOG_DEBUG("    Buttons (raw):        0x%02X\r\n", (uint16_t)data->steering_buttons);
  LOG_DEBUG("    Target Vel:           %lu\r\n", (uint64_t)data->steering_cruise_control_target_velocity);
}

// Read little-endian from data buffer in messages
static uint16_t read_u16(const uint8_t *data) {
  return (uint16_t)(data[0] | (data[1] << 8));
}

static uint32_t read_u32(const uint8_t *data) {
  return (uint32_t)(data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24));
}

static void parse_front_controller(uint16_t msg_id, uint8_t dlc, uint8_t *data) {
  switch (msg_id) {
    case 21: /* pedal (DLC: 7) */
      if (dlc >= 7) {
        s_front_controller_tx_struct.pedal_percentage = read_u32(&data[0]);
        s_front_controller_tx_struct.pedal_data = data[4];

        /**< Unpacked bitfields */
        const uint8_t raw = s_front_controller_tx_struct.pedal_data;
        s_front_controller_tx_struct.drive_state = (uint8_t)(raw & PEDAL_DATA_DRIVE_STATE_MASK);
        s_front_controller_tx_struct.brake_enabled = ((raw >> PEDAL_DATA_BRAKE_ENABLED_BIT) & 0x1U) != 0U;
        s_front_controller_tx_struct.regen_enabled = ((raw >> PEDAL_DATA_REGEN_ENABLED_BIT) & 0x1U) != 0U;
      }
      break;

    case 22: /* motor_velocity (DLC: 8) */
      if (dlc >= 8) {
        s_front_controller_tx_struct.motor_velocity_vehicle_velocity = read_u32(&data[0]);
        s_front_controller_tx_struct.motor_velocity_motor_velocity = read_u32(&data[4]);
      }
      break;

    case 23: /* motor_temperature (DLC: 8) */
      if (dlc >= 8) {
        s_front_controller_tx_struct.motor_temperature_heat_sink_temp = read_u32(&data[0]);
        s_front_controller_tx_struct.motor_temperature_motor_temp = read_u32(&data[4]);
      }
      break;

    case 31: /* fc_power_group_A (DLC: 8) */
      if (dlc >= 8) {
        s_front_controller_tx_struct.fc_power_group_A_rev_cam_current = read_u16(&data[0]);
        s_front_controller_tx_struct.fc_power_group_A_telem_current = read_u16(&data[2]);
        s_front_controller_tx_struct.fc_power_group_A_steering_current = read_u16(&data[4]);
        s_front_controller_tx_struct.fc_power_group_A_driver_fan_current = read_u16(&data[6]);
      }
      break;

    case 34: /* fc_power_lights_group (DLC: 8) */
      if (dlc >= 8) {
        s_front_controller_tx_struct.fc_power_lights_group_brake_light_sig_current = read_u16(&data[0]);
        s_front_controller_tx_struct.fc_power_lights_group_bps_light_sig_current = read_u16(&data[2]);
        s_front_controller_tx_struct.fc_power_lights_group_right_sig_current = read_u16(&data[4]);
        s_front_controller_tx_struct.fc_power_lights_group_left_sig_current = read_u16(&data[6]);
      }
      break;

    case 37: /* fc_power_group_B (DLC: 4) */
      if (dlc >= 4) {
        s_front_controller_tx_struct.fc_power_group_B_horn_current = read_u16(&data[0]);
        s_front_controller_tx_struct.fc_power_group_B_spare_current = read_u16(&data[2]);
      }
      break;

    default:
      break;
  }
}

static void parse_rear_controller(uint16_t msg_id, const uint8_t *data, uint8_t dlc) {
  switch (msg_id) {
    case 1: /* rear_controller_status (DLC: 2 per YAML; you may still receive 6 from legacy) */
      if (dlc >= 2) {
        const uint16_t triggers = read_u16(&data[0]);
        s_rear_controller_tx_struct.rear_controller_status_triggers = (uint8_t)(triggers & 0xFFu);
        s_rear_controller_tx_struct.bps_fault = (uint16_t)(triggers & RC_TRIG_BPS_FAULT_MASK);
        s_rear_controller_tx_struct.relay_state = (uint8_t)((triggers >> RC_TRIG_RELAY_STATE_BIT) & 0x1u);
        s_rear_controller_tx_struct.power_state = (uint8_t)((triggers >> RC_TRIG_POWER_STATE_BIT) & 0x1u);
        s_rear_controller_tx_struct.afe_status = (uint8_t)((triggers >> RC_TRIG_AFE_STATUS_BIT) & 0x1u);
        s_rear_controller_tx_struct.motor_precharge_complete = (uint8_t)((triggers >> RC_TRIG_MOTOR_PRECHARGE_COMPLETE_BIT) & 0x1u);
      }
      break;

    case 2: /* battery_stats_A (DLC: 6) */
      if (dlc >= 6) {
        s_rear_controller_tx_struct.battery_stats_A_pack_voltage = read_u16(&data[0]);
        s_rear_controller_tx_struct.battery_stats_A_pack_current = read_u16(&data[2]);
        s_rear_controller_tx_struct.battery_stats_A_pack_soc = read_u16(&data[4]);
      }
      break;

    case 3: /* battery_stats_B (DLC: 6) */
      if (dlc >= 6) {
        s_rear_controller_tx_struct.battery_stats_B_max_cell_voltage = read_u16(&data[0]);
        s_rear_controller_tx_struct.battery_stats_B_min_cell_voltage = read_u16(&data[2]);
        s_rear_controller_tx_struct.battery_stats_B_max_temperature = read_u16(&data[4]);
      }
      break;

    case 4: /* power_input_stats (DLC: 8) */
      if (dlc >= 8) {
        s_rear_controller_tx_struct.power_input_stats_input_dcdc_voltage = read_u16(&data[0]);
        s_rear_controller_tx_struct.power_input_stats_input_dcdc_current = read_u16(&data[2]);
        s_rear_controller_tx_struct.power_input_stats_input_aux_voltage = read_u16(&data[4]);
        s_rear_controller_tx_struct.power_input_stats_input_aux_current = read_u16(&data[6]);
      }
      break;

    case 59: /* AFE1_status_A (DLC: 7) */
      if (dlc >= 7) {
        s_rear_controller_tx_struct.AFE1_status_A_id = data[0];
        s_rear_controller_tx_struct.AFE1_status_A_voltage_0 = read_u16(&data[1]);
        s_rear_controller_tx_struct.AFE1_status_A_voltage_1 = read_u16(&data[3]);
        s_rear_controller_tx_struct.AFE1_status_A_voltage_2 = read_u16(&data[5]);
      }
      break;

    case 60: /* AFE1_status_B (DLC: 7) */
      if (dlc >= 7) {
        s_rear_controller_tx_struct.AFE1_status_B_id = data[0];
        s_rear_controller_tx_struct.AFE1_status_B_voltage_0 = read_u16(&data[1]);
        s_rear_controller_tx_struct.AFE1_status_B_voltage_1 = read_u16(&data[3]);
        s_rear_controller_tx_struct.AFE1_status_B_voltage_2 = read_u16(&data[5]);
      }
      break;

    case 61: /* AFE2_status_A (DLC: 7) */
      if (dlc >= 7) {
        s_rear_controller_tx_struct.AFE2_status_A_id = data[0];
        s_rear_controller_tx_struct.AFE2_status_A_voltage_0 = read_u16(&data[1]);
        s_rear_controller_tx_struct.AFE2_status_A_voltage_1 = read_u16(&data[3]);
        s_rear_controller_tx_struct.AFE2_status_A_voltage_2 = read_u16(&data[5]);
      }
      break;

    case 62: /* AFE2_status_B (DLC: 7) */
      if (dlc >= 7) {
        s_rear_controller_tx_struct.AFE2_status_B_id = data[0];
        s_rear_controller_tx_struct.AFE2_status_B_voltage_0 = read_u16(&data[1]);
        s_rear_controller_tx_struct.AFE2_status_B_voltage_1 = read_u16(&data[3]);
        s_rear_controller_tx_struct.AFE2_status_B_voltage_2 = read_u16(&data[5]);
      }
      break;

    case 63: /* AFE_temperature (DLC: 8) */
      if (dlc >= 8) {
        s_rear_controller_tx_struct.AFE_temperature_id = data[0];
        s_rear_controller_tx_struct.AFE_temperature_temperature_0 = data[1];
        s_rear_controller_tx_struct.AFE_temperature_temperature_1 = data[2];
        s_rear_controller_tx_struct.AFE_temperature_temperature_2 = data[3];
        s_rear_controller_tx_struct.AFE_temperature_temperature_3 = data[4];
        s_rear_controller_tx_struct.AFE_temperature_temperature_4 = data[5];
        s_rear_controller_tx_struct.AFE_temperature_temperature_5 = data[6];
        s_rear_controller_tx_struct.AFE_temperature_temperature_6 = data[7];
      }
      break;

    default:
      break;
  }
}

static void parse_steering(uint16_t msg_id, const uint8_t *data, uint8_t dlc) {
  switch (msg_id) {
    case 6: /* steering (DLC: 5) */
      if (dlc >= 5) {
        s_steering_tx_struct.steering_cruise_control_target_velocity = read_u32(&data[0]);
        uint8_t b = data[4];

        s_steering_tx_struct.steering_buttons = b;
        s_steering_tx_struct.drive_state = (uint8_t)(b & STEER_BTN_DRIVE_STATE_MASK);
        s_steering_tx_struct.lights = (uint8_t)((b & STEER_BTN_LIGHTS_MASK) >> STEER_BTN_LIGHTS_SHIFT);
        s_steering_tx_struct.cruise_control_enabled = ((b >> STEER_BTN_CRUISE_ENABLED_BIT) & 0x1u) != 0u;
        s_steering_tx_struct.hazard_enabled = ((b >> STEER_BTN_HAZARD_ENABLED_BIT) & 0x1u) != 0u;
        s_steering_tx_struct.horn_enabled = ((b >> STEER_BTN_HORN_ENABLED_BIT) & 0x1u) != 0u;
        s_steering_tx_struct.regen_enabled = ((b >> STEER_BTN_REGEN_ENABLED_BIT) & 0x1u) != 0u;
      }
      break;

    default:
      break;
  }
}

// Read datagram, update structs accordingly
static void update_board_data(Datagram *datagram) {
  const uint16_t full_id = datagram->id;
  const uint8_t source_id = (uint8_t)((full_id >> 5U) & 0x1FU);
  const uint8_t msg_id_local = (uint8_t)(full_id & 0x3FU);

  switch (source_id) {
    case SYSTEM_CAN_DEVICE_FRONT_CONTROLLER:
      parse_front_controller(msg_id_local, datagram->dlc, datagram->data);
      // print_front_controller(&s_front_controller_tx_struct);
      break;

    case SYSTEM_CAN_DEVICE_REAR_CONTROLLER:
      parse_rear_controller(msg_id_local, datagram->data, datagram->dlc);
      // print_rear_controller(&s_rear_controller_tx_struct);
      break;

    case SYSTEM_CAN_DEVICE_STEERING:
      parse_steering(msg_id_local, datagram->data, datagram->dlc);
      // print_steering(&s_steering_tx_struct);
      break;

    default:
      LOG_DEBUG("  [Unknown device: %u] id=0x%04X dlc=%u\r\n", (unsigned)source_id, (unsigned)full_id, (unsigned)datagram->dlc);
      break;
  }
}

static void print_all_boards(void) {
  LOG_DEBUG("\r\n================== BOARD STATUS SUMMARY ==================\r\n");
  print_front_controller(&s_front_controller_tx_struct);
  print_rear_controller(&s_rear_controller_tx_struct);
  print_steering(&s_steering_tx_struct);
  LOG_DEBUG("==========================================================\r\n\r\n");
}

TASK(telemetry_reader, TASK_STACK_1024) {
  Datagram datagram = { 0U };
  CanMessage message = { 0U };
  uint16_t msg_count = 0;
  StatusCode status = STATUS_CODE_OK;

  LOG_DEBUG("Telemetry smoke test");
  delay_ms(10U);

  while (true) {
    if (queue_receive(&s_can_storage.rx_queue.queue, &message, QUEUE_DELAY_BLOCKING) == STATUS_CODE_OK) {
      LOG_DEBUG("Received message\n");
      decode_can_message(&datagram, &message);
      msg_count++;
      LOG_DEBUG("[MSG #%u] ID: 0x%04X | DLC: %d\r\n", msg_count, datagram.id, datagram.dlc);
      delay_ms(10U);
      /* Wait for new data to be in the queue */

      update_board_data(&datagram);

      if (msg_count % 50U == 0U) {
        print_all_boards();
      }
    }
  }
}

#ifdef MS_PLATFORM_X86
#include "mpxe.h"
int main(int argc, char *argv[]) {
  mpxe_init(argc, argv);
#else
int main() {
#endif
  mcu_init();
  tasks_init();
  log_init();
  can_init(&s_can_storage, &s_can_settings);

  tasks_init_task(telemetry_reader, TASK_PRIORITY(3), NULL);

  tasks_start();

  LOG_DEBUG("exiting main?");
  return 0;
}
