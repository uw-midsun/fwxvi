/************************************************************************************************
 * @file   main.cc
 *
 * @brief  Main source file for {{ project_name }}
 *
 * @date   {{ current_date }}
 * @author Midnight Sun Team #24 - MSXVI
 ************************************************************************************************/

/* Standard library Headers */
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <string>

/* Inter-component Headers */
#include "client_connection.h"
#include "json_manager.h"
#include "ntp_server.h"
#include "server.h"

/* Intra-component Headers */
#include "app.h"
#include "app_callback.h"
#include "app_terminal.h"
#include "can_listener.h"
#include "can_scheduler.h"
{%- set ns = namespace(all_types=[]) %}
{%- for task in tasks %}
  {%- for ct in task.command_types_used %}
    {%- if ct not in ns.all_types %}
      {%- set ns.all_types = ns.all_types + [ct] %}
    {%- endif %}
  {%- endfor %}
{%- endfor %}
{%- for ct in ns.all_types %}
#include "{{ ct | lower }}_manager.h"
{%- endfor %}

JSONManager serverJSONManager;
CanListener serverCanListener;
CanScheduler serverCanScheduler;
{%- for ct in ns.all_types %}
{{ ct }}Manager server{{ ct }}Manager;
{%- endfor %}
{{""}}
/* Handler function defintions (imported from app_terminal.cc) */
{%- for fn_name in handler_impls.keys() %}
std::string {{ fn_name }}(const std::string &action, std::vector<std::string> &tokens);
{%- endfor %}

int main(int argc, char **argv) {
  std::cout << "Running Server" << std::endl;
  Server Server;
  Terminal applicationTerminal(&Server);

  Server.listenClients(8080, applicationMessageCallback, applicationConnectCallback);

#if USE_NETWORK_TIME_PROTOCOL == 1U
  NTPServer ntp_server;
  ntp_server.startListening("127.0.0.1", "time.google.com");
#endif

  serverCanListener.listenCanBus();
  serverCanScheduler.startCanScheduler();

  /* ------ can_defaults ------ */
  {%- for can_command in can_defaults %}
  serverCanScheduler.update_{{can_command}}({{can_defaults[can_command]}});
  {%- endfor%}

  
  /* ------ tasks ------ */ 
  std::vector<std::thread> task_threads; 

  {%- for task in tasks%}
  task_threads.emplace_back([&Server]() {
    while(true){
      std::string message;
      std::vector<std::string> tokens; 
      std::string command; 
      {{""}}
      {%- for command in task.commands %}
      {%- set parts = command.split() %}
      {%- set command_type = parts[0] | capitalize %}

      {%- if parts[0] == "CAN" %}
      {%- if parts|length >= 4 and parts[1] == "SET" %}
      /* CAN: SET {{ parts[2] }} {{ parts[3] }} */
      serverCanScheduler.update_{{ parts[2] | lower }}({{ parts[3] }});
      {%- else %}
      std::cerr << "Invalid CAN command: {{ command | replace('"','\\"') }}" << std::endl;
      {%- endif %}
      {%- elif parts[0] != "LOG" %}  
      tokens = { {%- for token in parts %}"{{ token }}"{% if not loop.last %}, {% endif %}{%- endfor %} };
      command = "{{parts[1] | lower}}";
      message = handle{{command_type}}Commands(command, tokens);
      
      Server.broadcastMessage(message);
      {{""}}
      {%- else %}
      std::cout << {{command[4: ]}} << std::endl;
      {%- endif%}
      
      {%- endfor %}   
      std::this_thread::sleep_for(std::chrono::milliseconds({{ task.period_ms }}));
    }
  });
  {%- endfor%}
  
  for (std::thread &t : task_threads){
      t.detach();
  }
  
  applicationTerminal.run();
  return 0;
}
{{""}}
{%- for fn_name, impl in handler_impls.items() %}
{{ impl }}
{{""}}
{%- endfor %}