/************************************************************************************************
 * @file   main.cc
 *
 * @brief  Main source file for {{ project_name }}
 *
 * @date   {{ current_date }}
 * @author Midnight Sun Team #24 - MSXVI
 ************************************************************************************************/

/* Standard library Headers */
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <string>

/* Inter-component Headers */
#include "client_connection.h"
#include "json_manager.h"
#include "ntp_server.h"
#include "server.h"

/* Intra-component Headers */
#include "app.h"
#include "app_callback.h"
#include "app_terminal.h"
#include "can_listener.h"
#include "can_scheduler.h"
{%- set ns = namespace(all_types=[]) %}
{%- for task in tasks %}
  {%- for ct in task.command_types_used %}
    {%- if ct not in ns.all_types %}
      {%- set ns.all_types = ns.all_types + [ct] %}
    {%- endif %}
  {%- endfor %}
{%- endfor %}
{%- for ct in ns.all_types %}
#include "{{ ct | lower }}_manager.h"
{%- endfor %}

JSONManager serverJSONManager;
CanListener serverCanListener;
CanScheduler serverCanScheduler;
{%- for ct in ns.all_types %}
{{ ct }}Manager server{{ ct }}Manager;
{%- endfor %}

int main(int argc, char **argv) {
  std::cout << "Running Server" << std::endl;
  Server Server;
  Terminal applicationTerminal(&Server);

  Server.listenClients(8080, applicationMessageCallback, applicationConnectCallback);

#if USE_NETWORK_TIME_PROTOCOL == 1U
  NTPServer ntp_server;
  ntp_server.startListening("127.0.0.1", "time.google.com");
#endif

  serverCanListener.listenCanBus();
  serverCanScheduler.startCanScheduler();

  /* ------ can_defaults ------ */
  {%- for can_command in can_defaults %}
  serverCanScheduler.update_{{can_command}}({{can_defaults[can_command]}});
  {%- endfor%}

  
  /* ------ tasks ------ */ 
  std::vector<std::thread> task_threads; 

  {%- for task in tasks%}
  task_threads.emplace_back([&Server]() {
    while(true){
      std::string message;
      std::string token_1;
      std::string token_2;
      {{""}}
      {%- for command in task.commands %}
      {%- set parts = command.split() %}
      {%- set command_type = parts[0] | capitalize %}
      {%- set action = parts[1] | upper %}

      {%- if parts[0] != "LOG" %} 
      token_1 =  {% if parts|length > 2 %}"{{ parts[2] }}"{% else %}" "{% endif %};
      token_2 = {% if parts|length > 3 %}"{{ parts[3] }}"{% else %}""{% endif %};
      {%- if "set" in parts[1] | lower %}
      message = server{{command_type}}Manager.create{{command_type}}Command(CommandCode::{{command_type | upper}}_{{action}}, token_2, token_1);
      {%- else %}
      message = server{{command_type}}Manager.create{{command_type}}Command(CommandCode::{{command_type | upper}}_{{action}}, token_1, token_2);
      {%-endif%}
      
      Server.broadcastMessage(message);
      {{""}}
      {%- else %}
      std::cout << {{command[4: ]}} << std::endl;
      {%- endif%}
      
      {%- endfor %}   
      std::this_thread::sleep_for(std::chrono::milliseconds({{ task.period_ms }}));
    }
  });
  {%- endfor%}
  
  for (std::thread &t : task_threads){
      t.detach();
  }
  
  applicationTerminal.run();
  return 0;
}
