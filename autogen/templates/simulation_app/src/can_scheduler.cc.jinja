/************************************************************************************************
 * @file   can_scheduler.cc
 *
 * @brief  Source file defining the CanScheduler class
 *
 * @date   {{ current_date }}
 * @author Aryan Kashem
 ************************************************************************************************/

/** @warning  This file is autogenerated */

/* Standard library Headers */
#include <iostream>
#include <cstring>

/* Inter-component Headers */
#include "system_can.h"

/* Intra-component Headers */
#include "can_scheduler.h"
{% set messages = messages | list %}

CanScheduler::CanScheduler() {
  m_isConnected = false;
  m_bcmCanSocket = -1;
}

void CanScheduler::scheduleCanMessages() {
  canFastCycleBCM.msg_head.opcode  = TX_SETUP;
  canFastCycleBCM.msg_head.can_id  = FAST_CYCLE_BCM_ID;
  canFastCycleBCM.msg_head.flags   = SETTIMER | STARTTIMER;
  canFastCycleBCM.msg_head.nframes = NUM_FAST_CYCLE_MESSAGES;
  canFastCycleBCM.msg_head.count   = 0;

  canFastCycleBCM.msg_head.ival1.tv_sec = 0U;
  canFastCycleBCM.msg_head.ival1.tv_usec = 0U;
  canFastCycleBCM.msg_head.ival2.tv_sec = FAST_CYCLE_SPEED_MS / 1000U;
  canFastCycleBCM.msg_head.ival2.tv_usec = (FAST_CYCLE_SPEED_MS % 1000U) * 1000U;

  {% set fast_message = namespace(count = 0) %}
  {%- for message in messages %}
  {%- if message.cycle == "fast" %}
  canFastCycleBCM.frame[FAST_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_{{ message.sender | upper }}_{{ message.name | upper }};
  canFastCycleBCM.frame[FAST_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].can_dlc = {{ (message.signals | sum(attribute='length') / 8) | int }}U;
  memset(canFastCycleBCM.frame[FAST_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  {%- set fast_message.count = fast_message.count + 1 %}
  {%- endif %}
  {%- endfor %}

  if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
    throw std::runtime_error("Failed to schedule CAN BCM Fast cycle messages");
  }

  canMediumCycleBCM.msg_head.opcode  = TX_SETUP;
  canMediumCycleBCM.msg_head.can_id  = MEDIUM_CYCLE_BCM_ID;
  canMediumCycleBCM.msg_head.flags   = SETTIMER | STARTTIMER;
  canMediumCycleBCM.msg_head.nframes = NUM_MEDIUM_CYCLE_MESSAGES;
  canMediumCycleBCM.msg_head.count   = 0;

  canMediumCycleBCM.msg_head.ival1.tv_sec = 0U;
  canMediumCycleBCM.msg_head.ival1.tv_usec = 0U;
  canMediumCycleBCM.msg_head.ival2.tv_sec = MEDIUM_CYCLE_SPEED_MS / 1000U;
  canMediumCycleBCM.msg_head.ival2.tv_usec = (MEDIUM_CYCLE_SPEED_MS % 1000U) * 1000U;

  {% set medium_message = namespace(count = 0) %}
  {%- for message in messages %}
  {%- if message.cycle == "medium" %}
  canMediumCycleBCM.frame[MEDIUM_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_{{ message.sender | upper }}_{{ message.name | upper }};
  canMediumCycleBCM.frame[MEDIUM_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].can_dlc = {{ (message.signals | sum(attribute='length') / 8) | int }}U;
  memset(canMediumCycleBCM.frame[MEDIUM_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  {%- set medium_message.count = medium_message.count + 1 %}
  {%- endif %}
  {%- endfor %}

  if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
    throw std::runtime_error("Failed to schedule CAN BCM Medium cycle messages");
  }

  canSlowCycleBCM.msg_head.opcode  = TX_SETUP;
  canSlowCycleBCM.msg_head.can_id  = SLOW_CYCLE_BCM_ID;
  canSlowCycleBCM.msg_head.flags   = SETTIMER | STARTTIMER;
  canSlowCycleBCM.msg_head.nframes = NUM_SLOW_CYCLE_MESSAGES;
  canSlowCycleBCM.msg_head.count   = 0;

  canSlowCycleBCM.msg_head.ival1.tv_sec = 0U;
  canSlowCycleBCM.msg_head.ival1.tv_usec = 0U;
  canSlowCycleBCM.msg_head.ival2.tv_sec = SLOW_CYCLE_SPEED_MS / 1000U;
  canSlowCycleBCM.msg_head.ival2.tv_usec = (SLOW_CYCLE_SPEED_MS % 1000U) * 1000U;

  {% set slow_message = namespace(count = 0) %}
  {%- for message in messages %}
  {%- if message.cycle == "slow" %}
  canSlowCycleBCM.frame[SLOW_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_{{ message.sender | upper }}_{{ message.name | upper }};
  canSlowCycleBCM.frame[SLOW_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].can_dlc = {{ (message.signals | sum(attribute='length') / 8) | int }}U;
  memset(canSlowCycleBCM.frame[SLOW_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  {%- set slow_message.count = slow_message.count + 1 %}
  {%- endif %}
  {%- endfor %}

  if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
    throw std::runtime_error("Failed to schedule CAN BCM Slow cycle messages");
  }
}

void CanScheduler::startCanScheduler() {
  try {
    m_bcmCanSocket = socket(PF_CAN, SOCK_DGRAM, CAN_BCM);

    if (m_bcmCanSocket < 0) {
      throw std::runtime_error("Error creating socket for CAN Broadcast Manager");
    }

    struct ifreq ifr;
    strcpy(ifr.ifr_name, CAN_INTERFACE_NAME.c_str());
    if (ioctl(m_bcmCanSocket, SIOCGIFINDEX, &ifr) < 0) {
      throw std::runtime_error("Error writing interface name to socketCAN file descriptor. Check if vcan0 is enabled?");
    }

    struct sockaddr_can addr = {};
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    if (connect(m_bcmCanSocket, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
      throw std::runtime_error("Error connecting to SocketCAN broadcast manager");
    }

    scheduleCanMessages();

  } catch (std::exception &e) {
    std::cerr << "Error running CAN Scheduler: " << e.what() << std::endl;
  }
}

{%- for message in messages %}
{%- for signal in message.signals %}
void CanScheduler::update_{{ message.name | lower }}_{{ signal.name | lower }}(uint{{ signal.length }}_t {{ signal.name | lower }}_value) {
  try {
    unsigned int start_byte = {{signal.start_bit // 8}};
    {%- if message.cycle == "fast" %}
    {% for i in range((signal.length + 7) // 8) %}
    canFastCycleBCM.frame[FAST_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].data[start_byte + {{ i }}U] = ({{ signal.name | lower }}_value >> {{ i * 8 }}U) & 0xFFU;{% endfor %}
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update {{ message.name | lower }} {{ signal.name | lower }}");
    }
    {%- endif %}
    {%- if message.cycle == "medium" %}
    {% for i in range((signal.length + 7) // 8) %}
    canMediumCycleBCM.frame[MEDIUM_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].data[start_byte + {{ i }}U] = ({{ signal.name | lower }}_value >> {{ i * 8 }}U) & 0xFFU;{% endfor %}
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update {{ message.name | lower }} {{ signal.name | lower }}}");
    }
    {%- endif %}
    {%- if message.cycle == "slow" %}
    {% for i in range((signal.length + 7) // 8) %}
    canSlowCycleBCM.frame[SLOW_{{ message.sender | upper }}_{{ message.name | upper }}_FRAME_INDEX].data[start_byte + {{ i }}U] = ({{ signal.name | lower }}_value >> {{ i * 8 }}U) & 0xFFU;{% endfor %}
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update {{ message.name | lower }} {{ signal.name | lower }}");
    }
    {%- endif %}
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
{%- endfor %}
{%- endfor %}
