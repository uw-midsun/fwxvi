/************************************************************************************************
 * @file   can_message_handler.cc
 *
 * @brief  Source file defining the Can Message Handler function
 *
 * @date   {{ current_date }}
 * @author Aryan Kashem
 ************************************************************************************************/

/** @warning  This file is autogenerated */

/* Standard library Headers */
#include <iostream>
#include <unordered_map>
#include <string>
#include <cstdint>

/* Inter-component Headers */
#include <nlohmann/json.hpp>

#include "system_can.h"

/* Intra-component Headers */
#include "can_listener.h"

{% set messages = messages | list -%}
{%- for message in messages %}
/**
 * @brief   Storage class for {{ message.name | lower }} CAN message
 */
struct {{ message.name | lower }} {
  {%- for signal in message.signals %}
  uint{{ signal.length }}_t {{ signal.name }}; /**< CAN signal '{{ signal.name }}' defined in *.yaml */
  {%- endfor %}

  /**
   * @brief   Decode new CAN data and update the storage for {{ message.name }}
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    
    {%- for signal in message.signals %}
    {
      raw_val = 0U;
      start_byte = {{signal.start_bit // 8}};
      {% for i in range((signal.length + 7) // 8) %}raw_val |= static_cast<uint64_t>(data[start_byte + {{ i }}]) << {{ i * 8 }}U;
      {% endfor %}
      {{ signal.name }} = raw_val;
    }
    {%- endfor %}
  }

  /**
   * @brief   Create a JSON object for {{ message.name }} using the storage
   */
  nlohmann::json to_json() const {
    return {
      {%- for signal in message.signals %}
      {"{{ signal.name }}", {{ signal.name }}}{% if not loop.last %},{% endif %}
      {%- endfor %}
    };
  }

  /**
   * @brief   Get the message name: {{ message.name }}
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "{{ message.name }}";
  }
};


{%- endfor %}

/**
 * @brief   Main CAN message Handler
 * @details This function shall dynamically allocate a struct based on the CAN ID
 *          This function shall decode the data, then update the CAN Cache 'm_canInfo' with JSON data
 * @param   id Can message ID
 * @param   data Pointer to the CAN message data
 */
void CanListener::canMessageHandler(uint32_t id, const uint8_t* data) {
  switch (id) {
  {%- for message in messages %}
    case SYSTEM_CAN_MESSAGE_{{message.sender | upper}}_{{message.name | upper}}: {
      {{ message.name | lower }} *message = new {{ message.name | lower }}();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
  {%- endfor %}
    default: {
      std::cout << "Unknown message ID: " << static_cast<int>(id) << std::endl;
    }
  }
}
