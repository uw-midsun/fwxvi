import cantools
import struct
import time
import tkinter as tk
from tkinter import font
import can
from collections import deque, defaultdict
import threading

# --- Globals ---
cache = defaultdict(lambda: deque(maxlen=50))
cache_lock = threading.Lock()
gui_labels = {}  # Stores {msg_name: {signal_name: label_widget}}
db = None
bus = None
root = None  # Global for the root window

# --- Configuration (Generated by Jinja2) ---
DBC_FILE = '{{ dbc_file }}'
DEFAULT_CHANNEL = '{{ default_channel }}'
DEFAULT_INTERFACE = '{{ default_interface }}'
FALLBACK_CHANNEL = '{{ fallback_channel }}'
FALLBACK_INTERFACE = '{{ fallback_interface }}'
UPDATE_INTERVAL_MS = {{ update_interval_ms }}
WINDOW_GEOMETRY = "{{ window_width }}x{{ window_height }}"

# --- Fonts (Generated by Jinja2) ---
FONT_FAMILY_TITLE = "{{ font_family_title }}"
FONT_SIZE_TITLE = {{ font_size_title }}
FONT_FAMILY_MONO = "{{ font_family_mono }}"
FONT_SIZE_MONO = {{ font_size_mono }}


def decoder(msg):
    """Decodes a single CAN message using the DBC."""
    global db
    try:
        decoded_data = db.decode_message(msg.arbitration_id, msg.data)
        return decoded_data
    except (KeyError, ValueError):
        return None


def listener_thread():
    """
    Thread to listen to the CAN bus.
    Receives messages, decodes them, and puts them in the thread-safe cache.
    """
    global db, bus, cache, cache_lock
    while True:
        msg = bus.recv()
        if msg is None:
            continue
        try:
            msg_def = db.get_message_by_frame_id(msg.arbitration_id)
            msg_name = msg_def.name
        except KeyError:
            msg_name = f"Unknown_ID_{hex(msg.arbitration_id)}"

        decoded_data = decoder(msg)
        if decoded_data:
            with cache_lock:
                cache[msg_name].append(decoded_data)


def update_gui():
    """
    Runs in the main GUI thread.
    Checks the cache for new data and updates the tkinter labels.
    """
    global cache, cache_lock, gui_labels, db, root
    with cache_lock:
        for msg_name, msg_deque in cache.items():
            if not msg_deque:  # Skip if no new data
                continue
            
            latest_data = msg_deque[-1] # Get the *most recent* message

            for signal_name, signal_value in latest_data.items():
                try:
                    # Format the value
                    if isinstance(signal_value, (float, int)):
                        try:
                            signal_def_for_type = db.get_message_by_name(msg_name).get_signal_by_name(signal_name)
                            if signal_def_for_type.is_float:
                                value_str = f"{signal_value: >8.2f}"
                            else:
                                value_str = f"{int(signal_value): >8}"
                        except Exception:
                            value_str = f"{signal_value: >8.2f}" # Fallback
                    else:
                        value_str = str(signal_value)

                    # Add units
                    try:
                        signal_def_unit = db.get_message_by_name(msg_name).get_signal_by_name(signal_name)
                        if signal_def_unit.unit:
                            value_str += f" {signal_def_unit.unit}"
                    except Exception:
                        pass 

                    # Update the correct label
                    gui_labels[msg_name][signal_name].config(text=value_str)

                except KeyError:
                    pass # GUI not built yet
    
    if root:
        root.after(UPDATE_INTERVAL_MS, update_gui) # Reschedule this function


def run_gui():
    """Builds and runs the main tkinter GUI."""
    global root, db, bus, gui_labels
    root = tk.Tk()
    root.title(f"CAN Explorer (Listening on {bus.channel_info})")
    root.geometry(WINDOW_GEOMETRY)

    # --- Fonts ---
    title_font = font.Font(family=FONT_FAMILY_TITLE, size=FONT_SIZE_TITLE, weight="bold")
    label_font = font.Font(family=FONT_FAMILY_MONO, size=FONT_SIZE_MONO) 
    value_font = font.Font(family=FONT_FAMILY_MONO, size=FONT_SIZE_MONO, weight="bold")

    # --- Scrollable Frame ---
    main_frame = tk.Frame(root)
    canvas = tk.Canvas(main_frame)
    scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(
            scrollregion=canvas.bbox("all")
        )
    )
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # --- Build GUI from DBC ---
    for msg in sorted(db.messages, key=lambda m: m.name):
        msg_name = msg.name
        
        msg_frame = tk.LabelFrame(
            scrollable_frame, 
            text=f"{msg_name} (ID: {hex(msg.frame_id)})",
            font=title_font,
            padx=10, 
            pady=10
        )
        msg_frame.pack(fill="x", expand=True, pady=5, padx=10)
        
        gui_labels[msg_name] = {}  # Init sub-dictionary

        for signal in sorted(msg.signals, key=lambda s: s.name):
            signal_name = signal.name
            
            row_frame = tk.Frame(msg_frame)
            row_frame.pack(fill="x")

            name_label = tk.Label(row_frame, text=f"{signal_name}:", width=30, anchor="w", font=label_font)
            name_label.pack(side="left", padx=5)

            value_label = tk.Label(row_frame, text="---", width=30, anchor="w", font=value_font, fg="#00008B")
            value_label.pack(side="left", padx=5)
            
            gui_labels[msg_name][signal_name] = value_label

    # --- Pack and Run ---
    main_frame.pack(fill="both", expand=True)
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    print("Starting GUI...")
    root.after(UPDATE_INTERVAL_MS, update_gui)  # Start the update loop
    root.mainloop()  # Start the main GUI event loop


if __name__ == "__main__":
    # --- 1. Load DBC ---
    try:
        db = cantools.database.load_file(DBC_FILE)
    except FileNotFoundError:
        print(f"DBC file '{DBC_FILE}' not found. Please place it in the same directory.")
        exit(1)
    except Exception as e:
        print(f"Error loading DBC file: {e}")
        exit(1)
    print("DBC file loaded successfully.")

    # --- 2. Connect to CAN Bus ---
    try:
        bus = can.interface.Bus(channel=DEFAULT_CHANNEL, interface=DEFAULT_INTERFACE)
        print(f"Connected to '{DEFAULT_INTERFACE}' bus on channel '{DEFAULT_CHANNEL}'.")
    except Exception:
        try:
            print(f"'{DEFAULT_INTERFACE}' bus failed, trying '{FALLBACK_INTERFACE}' on '{FALLBACK_CHANNEL}'...")
            bus = can.interface.Bus(channel=FALLBACK_CHANNEL, interface=FALLBACK_INTERFACE)
            print(f"Connected to '{FALLBACK_INTERFACE}' bus on channel '{FALLBACK_CHANNEL}'.")
        except OSError:
            print(f"Error: Could not connect to any CAN bus.")
            exit(1)

    # --- 3. Start Listener Thread ---
    listener = threading.Thread(target=listener_thread, daemon=True)
    listener.start()
    print("CAN listener thread started.")

    # --- 4. Run GUI ---
    run_gui()