/************************************************************************************************
 * @file   can_scheduler.cc
 *
 * @brief  Source file defining the CanScheduler class
 *
 * @date   2025-03-19
 * @author Aryan Kashem
 ************************************************************************************************/

/** @warning  This file is autogenerated */

/* Standard library Headers */
#include <iostream>
#include <cstring>

/* Inter-component Headers */
#include "system_can.h"

/* Intra-component Headers */
#include "can_scheduler.h"


CanScheduler::CanScheduler() {
  m_isConnected = false;
  m_bcmCanSocket = -1;
}

void CanScheduler::scheduleCanMessages() {
  canFastCycleBCM.msg_head.opcode  = TX_SETUP;
  canFastCycleBCM.msg_head.can_id  = FAST_CYCLE_BCM_ID;
  canFastCycleBCM.msg_head.flags   = SETTIMER | STARTTIMER;
  canFastCycleBCM.msg_head.nframes = NUM_FAST_CYCLE_MESSAGES;
  canFastCycleBCM.msg_head.count   = 0;

  canFastCycleBCM.msg_head.ival1.tv_sec = 0U;
  canFastCycleBCM.msg_head.ival1.tv_usec = 0U;
  canFastCycleBCM.msg_head.ival2.tv_sec = FAST_CYCLE_SPEED_MS / 1000U;
  canFastCycleBCM.msg_head.ival2.tv_usec = (FAST_CYCLE_SPEED_MS % 1000U) * 1000U;

  
  canFastCycleBCM.frame[FAST_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG;
  canFastCycleBCM.frame[FAST_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG_FRAME_INDEX].can_dlc = 4U;
  memset(canFastCycleBCM.frame[FAST_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_BATTERY_VT;
  canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].can_dlc = 8U;
  memset(canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canFastCycleBCM.frame[FAST_CENTRE_CONSOLE_CC_PEDAL_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_CENTRE_CONSOLE_CC_PEDAL;
  canFastCycleBCM.frame[FAST_CENTRE_CONSOLE_CC_PEDAL_FRAME_INDEX].can_dlc = 5U;
  memset(canFastCycleBCM.frame[FAST_CENTRE_CONSOLE_CC_PEDAL_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);

  if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
    throw std::runtime_error("Failed to schedule CAN BCM Fast cycle messages");
  }

  canMediumCycleBCM.msg_head.opcode  = TX_SETUP;
  canMediumCycleBCM.msg_head.can_id  = MEDIUM_CYCLE_BCM_ID;
  canMediumCycleBCM.msg_head.flags   = SETTIMER | STARTTIMER;
  canMediumCycleBCM.msg_head.nframes = NUM_MEDIUM_CYCLE_MESSAGES;
  canMediumCycleBCM.msg_head.count   = 0;

  canMediumCycleBCM.msg_head.ival1.tv_sec = 0U;
  canMediumCycleBCM.msg_head.ival1.tv_usec = 0U;
  canMediumCycleBCM.msg_head.ival2.tv_sec = MEDIUM_CYCLE_SPEED_MS / 1000U;
  canMediumCycleBCM.msg_head.ival2.tv_usec = (MEDIUM_CYCLE_SPEED_MS % 1000U) * 1000U;

  
  canMediumCycleBCM.frame[MEDIUM_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG;
  canMediumCycleBCM.frame[MEDIUM_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG_FRAME_INDEX].can_dlc = 4U;
  memset(canMediumCycleBCM.frame[MEDIUM_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_IMU_GYRO_DATA;
  canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].can_dlc = 6U;
  memset(canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_IMU_ACCEL_DATA;
  canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].can_dlc = 6U;
  memset(canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_BATTERY_STATUS;
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].can_dlc = 7U;
  memset(canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_MC_STATUS;
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].can_dlc = 7U;
  memset(canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_MOTOR_CONTROLLER_VC;
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].can_dlc = 8U;
  memset(canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_VELOCITY_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_MOTOR_VELOCITY;
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_VELOCITY_FRAME_INDEX].can_dlc = 5U;
  memset(canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_VELOCITY_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_MOTOR_SINK_TEMPS;
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].can_dlc = 8U;
  memset(canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_DSP_BOARD_TEMPS_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_DSP_BOARD_TEMPS;
  canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_DSP_BOARD_TEMPS_FRAME_INDEX].can_dlc = 4U;
  memset(canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_DSP_BOARD_TEMPS_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_CENTRE_CONSOLE_CC_INFO;
  canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].can_dlc = 8U;
  memset(canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_STEERING_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_CENTRE_CONSOLE_CC_STEERING;
  canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_STEERING_FRAME_INDEX].can_dlc = 2U;
  memset(canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_STEERING_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_REGEN_PERCENTAGE_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_CENTRE_CONSOLE_CC_REGEN_PERCENTAGE;
  canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_REGEN_PERCENTAGE_FRAME_INDEX].can_dlc = 4U;
  memset(canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_REGEN_PERCENTAGE_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);

  if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
    throw std::runtime_error("Failed to schedule CAN BCM Medium cycle messages");
  }

  canSlowCycleBCM.msg_head.opcode  = TX_SETUP;
  canSlowCycleBCM.msg_head.can_id  = SLOW_CYCLE_BCM_ID;
  canSlowCycleBCM.msg_head.flags   = SETTIMER | STARTTIMER;
  canSlowCycleBCM.msg_head.nframes = NUM_SLOW_CYCLE_MESSAGES;
  canSlowCycleBCM.msg_head.count   = 0;

  canSlowCycleBCM.msg_head.ival1.tv_sec = 0U;
  canSlowCycleBCM.msg_head.ival1.tv_usec = 0U;
  canSlowCycleBCM.msg_head.ival2.tv_sec = SLOW_CYCLE_SPEED_MS / 1000U;
  canSlowCycleBCM.msg_head.ival2.tv_usec = (SLOW_CYCLE_SPEED_MS % 1000U) * 1000U;

  
  canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_TELEMETRY_TELEMETRY;
  canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].can_dlc = 8U;
  memset(canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canSlowCycleBCM.frame[SLOW_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG;
  canSlowCycleBCM.frame[SLOW_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG_FRAME_INDEX].can_dlc = 4U;
  memset(canSlowCycleBCM.frame[SLOW_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_BATTERY_INFO;
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].can_dlc = 6U;
  memset(canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_RELAY_INFO_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_BATTERY_RELAY_INFO;
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_RELAY_INFO_FRAME_INDEX].can_dlc = 1U;
  memset(canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_RELAY_INFO_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_AFE1_STATUS;
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].can_dlc = 8U;
  memset(canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_AFE2_STATUS;
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].can_dlc = 8U;
  memset(canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].can_id = SYSTEM_CAN_MESSAGE_BMS_CARRIER_AFE3_STATUS;
  canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].can_dlc = 8U;
  memset(canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data, 0U, MAX_MESSAGE_LENGTH);

  if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
    throw std::runtime_error("Failed to schedule CAN BCM Slow cycle messages");
  }
}

void CanScheduler::startCanScheduler() {
  try {
    m_bcmCanSocket = socket(PF_CAN, SOCK_DGRAM, CAN_BCM);

    if (m_bcmCanSocket < 0) {
      throw std::runtime_error("Error creating socket for CAN Broadcast Manager");
    }

    struct ifreq ifr;
    strcpy(ifr.ifr_name, CAN_INTERFACE_NAME.c_str());
    if (ioctl(m_bcmCanSocket, SIOCGIFINDEX, &ifr) < 0) {
      throw std::runtime_error("Error writing interface name to socketCAN file descriptor. Check if vcan0 is enabled?");
    }

    struct sockaddr_can addr = {};
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    if (connect(m_bcmCanSocket, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
      throw std::runtime_error("Error connecting to SocketCAN broadcast manager");
    }

    scheduleCanMessages();

  } catch (std::exception &e) {
    std::cerr << "Error running CAN Scheduler: " << e.what() << std::endl;
  }
}
void CanScheduler::update_telemetry_telemetry_data(uint64_t telemetry_data_value) {
  try {
    unsigned int start_byte = 0;
    
    canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data[start_byte + 0U] = (telemetry_data_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data[start_byte + 1U] = (telemetry_data_value >> 8U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data[start_byte + 2U] = (telemetry_data_value >> 16U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data[start_byte + 3U] = (telemetry_data_value >> 24U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data[start_byte + 4U] = (telemetry_data_value >> 32U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data[start_byte + 5U] = (telemetry_data_value >> 40U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data[start_byte + 6U] = (telemetry_data_value >> 48U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX].data[start_byte + 7U] = (telemetry_data_value >> 56U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update telemetry telemetry_data");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_fast_one_shot_msg_sig1(uint16_t sig1_value) {
  try {
    unsigned int start_byte = 0;
    
    canFastCycleBCM.frame[FAST_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 0U] = (sig1_value >> 0U) & 0xFFU;
    canFastCycleBCM.frame[FAST_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 1U] = (sig1_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update fast_one_shot_msg sig1");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_fast_one_shot_msg_sig2(uint16_t sig2_value) {
  try {
    unsigned int start_byte = 2;
    
    canFastCycleBCM.frame[FAST_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 0U] = (sig2_value >> 0U) & 0xFFU;
    canFastCycleBCM.frame[FAST_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 1U] = (sig2_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update fast_one_shot_msg sig2");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_medium_one_shot_msg_sig1(uint16_t sig1_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 0U] = (sig1_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 1U] = (sig1_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update medium_one_shot_msg sig1}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_medium_one_shot_msg_sig2(uint16_t sig2_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 0U] = (sig2_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 1U] = (sig2_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update medium_one_shot_msg sig2}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_slow_one_shot_msg_sig1(uint16_t sig1_value) {
  try {
    unsigned int start_byte = 0;
    
    canSlowCycleBCM.frame[SLOW_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 0U] = (sig1_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 1U] = (sig1_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update slow_one_shot_msg sig1");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_slow_one_shot_msg_sig2(uint16_t sig2_value) {
  try {
    unsigned int start_byte = 2;
    
    canSlowCycleBCM.frame[SLOW_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 0U] = (sig2_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG_FRAME_INDEX].data[start_byte + 1U] = (sig2_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update slow_one_shot_msg sig2");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_gyro_data_x_axis(uint16_t x_axis_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].data[start_byte + 0U] = (x_axis_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].data[start_byte + 1U] = (x_axis_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update gyro_data x_axis}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_gyro_data_y_axis(uint16_t y_axis_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].data[start_byte + 0U] = (y_axis_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].data[start_byte + 1U] = (y_axis_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update gyro_data y_axis}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_gyro_data_z_axis(uint16_t z_axis_value) {
  try {
    unsigned int start_byte = 4;
    
    canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].data[start_byte + 0U] = (z_axis_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_IMU_GYRO_DATA_FRAME_INDEX].data[start_byte + 1U] = (z_axis_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update gyro_data z_axis}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_accel_data_x_axis(uint16_t x_axis_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].data[start_byte + 0U] = (x_axis_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].data[start_byte + 1U] = (x_axis_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update accel_data x_axis}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_accel_data_y_axis(uint16_t y_axis_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].data[start_byte + 0U] = (y_axis_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].data[start_byte + 1U] = (y_axis_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update accel_data y_axis}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_accel_data_z_axis(uint16_t z_axis_value) {
  try {
    unsigned int start_byte = 4;
    
    canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].data[start_byte + 0U] = (z_axis_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX].data[start_byte + 1U] = (z_axis_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update accel_data z_axis}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_status_fault(uint16_t fault_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].data[start_byte + 0U] = (fault_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].data[start_byte + 1U] = (fault_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_status fault}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_status_fault_val(uint16_t fault_val_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].data[start_byte + 0U] = (fault_val_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].data[start_byte + 1U] = (fault_val_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_status fault_val}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_status_aux_batt_v(uint16_t aux_batt_v_value) {
  try {
    unsigned int start_byte = 4;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].data[start_byte + 0U] = (aux_batt_v_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].data[start_byte + 1U] = (aux_batt_v_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_status aux_batt_v}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_status_afe_status(uint8_t afe_status_value) {
  try {
    unsigned int start_byte = 6;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_BATTERY_STATUS_FRAME_INDEX].data[start_byte + 0U] = (afe_status_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_status afe_status}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_vt_voltage(uint16_t voltage_value) {
  try {
    unsigned int start_byte = 0;
    
    canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data[start_byte + 0U] = (voltage_value >> 0U) & 0xFFU;
    canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data[start_byte + 1U] = (voltage_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_vt voltage");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_vt_current(uint16_t current_value) {
  try {
    unsigned int start_byte = 2;
    
    canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data[start_byte + 0U] = (current_value >> 0U) & 0xFFU;
    canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data[start_byte + 1U] = (current_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_vt current");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_vt_temperature(uint16_t temperature_value) {
  try {
    unsigned int start_byte = 4;
    
    canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data[start_byte + 0U] = (temperature_value >> 0U) & 0xFFU;
    canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data[start_byte + 1U] = (temperature_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_vt temperature");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_vt_batt_perc(uint16_t batt_perc_value) {
  try {
    unsigned int start_byte = 6;
    
    canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data[start_byte + 0U] = (batt_perc_value >> 0U) & 0xFFU;
    canFastCycleBCM.frame[FAST_BMS_CARRIER_BATTERY_VT_FRAME_INDEX].data[start_byte + 1U] = (batt_perc_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_vt batt_perc");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_info_fan1(uint8_t fan1_value) {
  try {
    unsigned int start_byte = 0;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].data[start_byte + 0U] = (fan1_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_info fan1");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_info_fan2(uint8_t fan2_value) {
  try {
    unsigned int start_byte = 1;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].data[start_byte + 0U] = (fan2_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_info fan2");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_info_max_cell_v(uint16_t max_cell_v_value) {
  try {
    unsigned int start_byte = 2;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].data[start_byte + 0U] = (max_cell_v_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].data[start_byte + 1U] = (max_cell_v_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_info max_cell_v");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_info_min_cell_v(uint16_t min_cell_v_value) {
  try {
    unsigned int start_byte = 4;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].data[start_byte + 0U] = (min_cell_v_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_INFO_FRAME_INDEX].data[start_byte + 1U] = (min_cell_v_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_info min_cell_v");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_mc_status_limit_bitset_l(uint8_t limit_bitset_l_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].data[start_byte + 0U] = (limit_bitset_l_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update mc_status limit_bitset_l}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_mc_status_error_bitset_l(uint8_t error_bitset_l_value) {
  try {
    unsigned int start_byte = 1;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].data[start_byte + 0U] = (error_bitset_l_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update mc_status error_bitset_l}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_mc_status_limit_bitset_r(uint8_t limit_bitset_r_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].data[start_byte + 0U] = (limit_bitset_r_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update mc_status limit_bitset_r}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_mc_status_error_bitset_r(uint8_t error_bitset_r_value) {
  try {
    unsigned int start_byte = 3;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].data[start_byte + 0U] = (error_bitset_r_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update mc_status error_bitset_r}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_mc_status_board_fault_bitset(uint8_t board_fault_bitset_value) {
  try {
    unsigned int start_byte = 4;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].data[start_byte + 0U] = (board_fault_bitset_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update mc_status board_fault_bitset}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_mc_status_overtemp_bitset(uint8_t overtemp_bitset_value) {
  try {
    unsigned int start_byte = 5;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].data[start_byte + 0U] = (overtemp_bitset_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update mc_status overtemp_bitset}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_mc_status_precharge_status(uint8_t precharge_status_value) {
  try {
    unsigned int start_byte = 6;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MC_STATUS_FRAME_INDEX].data[start_byte + 0U] = (precharge_status_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update mc_status precharge_status}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_controller_vc_mc_voltage_l(uint16_t mc_voltage_l_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data[start_byte + 0U] = (mc_voltage_l_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data[start_byte + 1U] = (mc_voltage_l_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_controller_vc mc_voltage_l}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_controller_vc_mc_current_l(uint16_t mc_current_l_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data[start_byte + 0U] = (mc_current_l_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data[start_byte + 1U] = (mc_current_l_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_controller_vc mc_current_l}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_controller_vc_mc_voltage_r(uint16_t mc_voltage_r_value) {
  try {
    unsigned int start_byte = 4;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data[start_byte + 0U] = (mc_voltage_r_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data[start_byte + 1U] = (mc_voltage_r_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_controller_vc mc_voltage_r}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_controller_vc_mc_current_r(uint16_t mc_current_r_value) {
  try {
    unsigned int start_byte = 6;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data[start_byte + 0U] = (mc_current_r_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_CONTROLLER_VC_FRAME_INDEX].data[start_byte + 1U] = (mc_current_r_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_controller_vc mc_current_r}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_velocity_velocity_l(uint16_t velocity_l_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_VELOCITY_FRAME_INDEX].data[start_byte + 0U] = (velocity_l_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_VELOCITY_FRAME_INDEX].data[start_byte + 1U] = (velocity_l_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_velocity velocity_l}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_velocity_velocity_r(uint16_t velocity_r_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_VELOCITY_FRAME_INDEX].data[start_byte + 0U] = (velocity_r_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_VELOCITY_FRAME_INDEX].data[start_byte + 1U] = (velocity_r_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_velocity velocity_r}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_velocity_brakes_enabled(uint8_t brakes_enabled_value) {
  try {
    unsigned int start_byte = 4;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_VELOCITY_FRAME_INDEX].data[start_byte + 0U] = (brakes_enabled_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_velocity brakes_enabled}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_sink_temps_motor_temp_l(uint16_t motor_temp_l_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data[start_byte + 0U] = (motor_temp_l_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data[start_byte + 1U] = (motor_temp_l_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_sink_temps motor_temp_l}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_sink_temps_heatsink_temp_l(uint16_t heatsink_temp_l_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data[start_byte + 0U] = (heatsink_temp_l_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data[start_byte + 1U] = (heatsink_temp_l_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_sink_temps heatsink_temp_l}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_sink_temps_motor_temp_r(uint16_t motor_temp_r_value) {
  try {
    unsigned int start_byte = 4;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data[start_byte + 0U] = (motor_temp_r_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data[start_byte + 1U] = (motor_temp_r_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_sink_temps motor_temp_r}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_motor_sink_temps_heatsink_temp_r(uint16_t heatsink_temp_r_value) {
  try {
    unsigned int start_byte = 6;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data[start_byte + 0U] = (heatsink_temp_r_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_MOTOR_SINK_TEMPS_FRAME_INDEX].data[start_byte + 1U] = (heatsink_temp_r_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update motor_sink_temps heatsink_temp_r}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_dsp_board_temps_dsp_temp_l(uint16_t dsp_temp_l_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_DSP_BOARD_TEMPS_FRAME_INDEX].data[start_byte + 0U] = (dsp_temp_l_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_DSP_BOARD_TEMPS_FRAME_INDEX].data[start_byte + 1U] = (dsp_temp_l_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update dsp_board_temps dsp_temp_l}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_dsp_board_temps_dsp_temp_r(uint16_t dsp_temp_r_value) {
  try {
    unsigned int start_byte = 2;
    
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_DSP_BOARD_TEMPS_FRAME_INDEX].data[start_byte + 0U] = (dsp_temp_r_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_BMS_CARRIER_DSP_BOARD_TEMPS_FRAME_INDEX].data[start_byte + 1U] = (dsp_temp_r_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update dsp_board_temps dsp_temp_r}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_battery_relay_info_state(uint8_t state_value) {
  try {
    unsigned int start_byte = 0;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_BATTERY_RELAY_INFO_FRAME_INDEX].data[start_byte + 0U] = (state_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update battery_relay_info state");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe1_status_id(uint8_t id_value) {
  try {
    unsigned int start_byte = 0;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data[start_byte + 0U] = (id_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe1_status id");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe1_status_temp(uint8_t temp_value) {
  try {
    unsigned int start_byte = 1;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data[start_byte + 0U] = (temp_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe1_status temp");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe1_status_v1(uint16_t v1_value) {
  try {
    unsigned int start_byte = 2;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v1_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v1_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe1_status v1");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe1_status_v2(uint16_t v2_value) {
  try {
    unsigned int start_byte = 4;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v2_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v2_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe1_status v2");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe1_status_v3(uint16_t v3_value) {
  try {
    unsigned int start_byte = 6;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v3_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE1_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v3_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe1_status v3");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe2_status_id(uint8_t id_value) {
  try {
    unsigned int start_byte = 0;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data[start_byte + 0U] = (id_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe2_status id");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe2_status_temp(uint8_t temp_value) {
  try {
    unsigned int start_byte = 1;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data[start_byte + 0U] = (temp_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe2_status temp");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe2_status_v1(uint16_t v1_value) {
  try {
    unsigned int start_byte = 2;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v1_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v1_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe2_status v1");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe2_status_v2(uint16_t v2_value) {
  try {
    unsigned int start_byte = 4;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v2_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v2_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe2_status v2");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe2_status_v3(uint16_t v3_value) {
  try {
    unsigned int start_byte = 6;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v3_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE2_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v3_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe2_status v3");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe3_status_id(uint8_t id_value) {
  try {
    unsigned int start_byte = 0;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data[start_byte + 0U] = (id_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe3_status id");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe3_status_temp(uint8_t temp_value) {
  try {
    unsigned int start_byte = 1;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data[start_byte + 0U] = (temp_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe3_status temp");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe3_status_v1(uint16_t v1_value) {
  try {
    unsigned int start_byte = 2;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v1_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v1_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe3_status v1");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe3_status_v2(uint16_t v2_value) {
  try {
    unsigned int start_byte = 4;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v2_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v2_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe3_status v2");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_afe3_status_v3(uint16_t v3_value) {
  try {
    unsigned int start_byte = 6;
    
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data[start_byte + 0U] = (v3_value >> 0U) & 0xFFU;
    canSlowCycleBCM.frame[SLOW_BMS_CARRIER_AFE3_STATUS_FRAME_INDEX].data[start_byte + 1U] = (v3_value >> 8U) & 0xFFU;
    if (write(m_bcmCanSocket, &canSlowCycleBCM, sizeof(canSlowCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update afe3_status v3");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_pedal_throttle_output(uint32_t throttle_output_value) {
  try {
    unsigned int start_byte = 0;
    
    canFastCycleBCM.frame[FAST_CENTRE_CONSOLE_CC_PEDAL_FRAME_INDEX].data[start_byte + 0U] = (throttle_output_value >> 0U) & 0xFFU;
    canFastCycleBCM.frame[FAST_CENTRE_CONSOLE_CC_PEDAL_FRAME_INDEX].data[start_byte + 1U] = (throttle_output_value >> 8U) & 0xFFU;
    canFastCycleBCM.frame[FAST_CENTRE_CONSOLE_CC_PEDAL_FRAME_INDEX].data[start_byte + 2U] = (throttle_output_value >> 16U) & 0xFFU;
    canFastCycleBCM.frame[FAST_CENTRE_CONSOLE_CC_PEDAL_FRAME_INDEX].data[start_byte + 3U] = (throttle_output_value >> 24U) & 0xFFU;
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_pedal throttle_output");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_pedal_brake_output(uint8_t brake_output_value) {
  try {
    unsigned int start_byte = 4;
    
    canFastCycleBCM.frame[FAST_CENTRE_CONSOLE_CC_PEDAL_FRAME_INDEX].data[start_byte + 0U] = (brake_output_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canFastCycleBCM, sizeof(canFastCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_pedal brake_output");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_info_target_velocity(uint32_t target_velocity_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data[start_byte + 0U] = (target_velocity_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data[start_byte + 1U] = (target_velocity_value >> 8U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data[start_byte + 2U] = (target_velocity_value >> 16U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data[start_byte + 3U] = (target_velocity_value >> 24U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_info target_velocity}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_info_drive_state(uint8_t drive_state_value) {
  try {
    unsigned int start_byte = 4;
    
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data[start_byte + 0U] = (drive_state_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_info drive_state}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_info_cruise_control(uint8_t cruise_control_value) {
  try {
    unsigned int start_byte = 5;
    
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data[start_byte + 0U] = (cruise_control_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_info cruise_control}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_info_regen_braking(uint8_t regen_braking_value) {
  try {
    unsigned int start_byte = 6;
    
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data[start_byte + 0U] = (regen_braking_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_info regen_braking}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_info_hazard_enabled(uint8_t hazard_enabled_value) {
  try {
    unsigned int start_byte = 7;
    
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_INFO_FRAME_INDEX].data[start_byte + 0U] = (hazard_enabled_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_info hazard_enabled}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_steering_input_cc(uint8_t input_cc_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_STEERING_FRAME_INDEX].data[start_byte + 0U] = (input_cc_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_steering input_cc}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_steering_input_lights(uint8_t input_lights_value) {
  try {
    unsigned int start_byte = 1;
    
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_STEERING_FRAME_INDEX].data[start_byte + 0U] = (input_lights_value >> 0U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_steering input_lights}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}
void CanScheduler::update_cc_regen_percentage_percent(uint32_t percent_value) {
  try {
    unsigned int start_byte = 0;
    
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_REGEN_PERCENTAGE_FRAME_INDEX].data[start_byte + 0U] = (percent_value >> 0U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_REGEN_PERCENTAGE_FRAME_INDEX].data[start_byte + 1U] = (percent_value >> 8U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_REGEN_PERCENTAGE_FRAME_INDEX].data[start_byte + 2U] = (percent_value >> 16U) & 0xFFU;
    canMediumCycleBCM.frame[MEDIUM_CENTRE_CONSOLE_CC_REGEN_PERCENTAGE_FRAME_INDEX].data[start_byte + 3U] = (percent_value >> 24U) & 0xFFU;
    if (write(m_bcmCanSocket, &canMediumCycleBCM, sizeof(canMediumCycleBCM)) < 0) {
      throw std::runtime_error("Failed to update cc_regen_percentage percent}");
    }
  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}