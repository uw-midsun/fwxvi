/************************************************************************************************
 * @file   can_message_handler.cc
 *
 * @brief  Source file defining the Can Message Handler function
 *
 * @date   2025-09-17
 * @author Aryan Kashem
 ************************************************************************************************/

/** @warning  This file is autogenerated */

/* Standard library Headers */
#include <cstdint>
#include <iostream>
#include <string>
#include <unordered_map>

/* Inter-component Headers */
#include <nlohmann/json.hpp>

#include "system_can.h"

/* Intra-component Headers */
#include "can_listener.h"

/**
 * @brief   Storage class for test_data CAN message
 */
struct test_data {
  uint16_t fault;      /**< CAN signal 'fault' defined in *.yaml */
  uint16_t fault_val;  /**< CAN signal 'fault_val' defined in *.yaml */
  uint16_t aux_batt_v; /**< CAN signal 'aux_batt_v' defined in *.yaml */
  uint8_t afe_status;  /**< CAN signal 'afe_status' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for test_data
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      fault = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 2;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      fault_val = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 4;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      aux_batt_v = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 6;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;

      afe_status = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for test_data using the storage
   */
  nlohmann::json to_json() const {
    return { { "fault", fault }, { "fault_val", fault_val }, { "aux_batt_v", aux_batt_v }, { "afe_status", afe_status } };
  }

  /**
   * @brief   Get the message name: test_data
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "test_data";
  }
};
/**
 * @brief   Storage class for gyro_data CAN message
 */
struct gyro_data {
  uint16_t x_axis; /**< CAN signal 'x_axis' defined in *.yaml */
  uint16_t y_axis; /**< CAN signal 'y_axis' defined in *.yaml */
  uint16_t z_axis; /**< CAN signal 'z_axis' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for gyro_data
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      x_axis = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 2;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      y_axis = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 4;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      z_axis = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for gyro_data using the storage
   */
  nlohmann::json to_json() const {
    return { { "x_axis", x_axis }, { "y_axis", y_axis }, { "z_axis", z_axis } };
  }

  /**
   * @brief   Get the message name: gyro_data
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "gyro_data";
  }
};
/**
 * @brief   Storage class for accel_data CAN message
 */
struct accel_data {
  uint16_t x_axis; /**< CAN signal 'x_axis' defined in *.yaml */
  uint16_t y_axis; /**< CAN signal 'y_axis' defined in *.yaml */
  uint16_t z_axis; /**< CAN signal 'z_axis' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for accel_data
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      x_axis = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 2;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      y_axis = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 4;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      z_axis = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for accel_data using the storage
   */
  nlohmann::json to_json() const {
    return { { "x_axis", x_axis }, { "y_axis", y_axis }, { "z_axis", z_axis } };
  }

  /**
   * @brief   Get the message name: accel_data
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "accel_data";
  }
};
/**
 * @brief   Storage class for fast_one_shot_msg CAN message
 */
struct fast_one_shot_msg {
  uint16_t sig1; /**< CAN signal 'sig1' defined in *.yaml */
  uint16_t sig2; /**< CAN signal 'sig2' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for fast_one_shot_msg
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      sig1 = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 2;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      sig2 = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for fast_one_shot_msg using the storage
   */
  nlohmann::json to_json() const {
    return { { "sig1", sig1 }, { "sig2", sig2 } };
  }

  /**
   * @brief   Get the message name: fast_one_shot_msg
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "fast_one_shot_msg";
  }
};
/**
 * @brief   Storage class for medium_one_shot_msg CAN message
 */
struct medium_one_shot_msg {
  uint16_t sig1; /**< CAN signal 'sig1' defined in *.yaml */
  uint16_t sig2; /**< CAN signal 'sig2' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for medium_one_shot_msg
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      sig1 = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 2;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      sig2 = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for medium_one_shot_msg using the storage
   */
  nlohmann::json to_json() const {
    return { { "sig1", sig1 }, { "sig2", sig2 } };
  }

  /**
   * @brief   Get the message name: medium_one_shot_msg
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "medium_one_shot_msg";
  }
};
/**
 * @brief   Storage class for slow_one_shot_msg CAN message
 */
struct slow_one_shot_msg {
  uint16_t sig1; /**< CAN signal 'sig1' defined in *.yaml */
  uint16_t sig2; /**< CAN signal 'sig2' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for slow_one_shot_msg
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      sig1 = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 2;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;

      sig2 = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for slow_one_shot_msg using the storage
   */
  nlohmann::json to_json() const {
    return { { "sig1", sig1 }, { "sig2", sig2 } };
  }

  /**
   * @brief   Get the message name: slow_one_shot_msg
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "slow_one_shot_msg";
  }
};
/**
 * @brief   Storage class for steering_state CAN message
 */
struct steering_state {
  uint32_t target_velocity; /**< CAN signal 'target_velocity' defined in *.yaml */
  uint8_t drive_state;      /**< CAN signal 'drive_state' defined in *.yaml */
  uint8_t cruise_control;   /**< CAN signal 'cruise_control' defined in *.yaml */
  uint8_t regen_braking;    /**< CAN signal 'regen_braking' defined in *.yaml */
  uint8_t hazard_enabled;   /**< CAN signal 'hazard_enabled' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for steering_state
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 2]) << 16U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 3]) << 24U;

      target_velocity = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 4;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;

      drive_state = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 5;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;

      cruise_control = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 6;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;

      regen_braking = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 7;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;

      hazard_enabled = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for steering_state using the storage
   */
  nlohmann::json to_json() const {
    return { { "target_velocity", target_velocity }, { "drive_state", drive_state }, { "cruise_control", cruise_control }, { "regen_braking", regen_braking }, { "hazard_enabled", hazard_enabled } };
  }

  /**
   * @brief   Get the message name: steering_state
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "steering_state";
  }
};
/**
 * @brief   Storage class for telemetry CAN message
 */
struct telemetry {
  uint64_t telemetry_data; /**< CAN signal 'telemetry_data' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for telemetry
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 2]) << 16U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 3]) << 24U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 4]) << 32U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 5]) << 40U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 6]) << 48U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 7]) << 56U;

      telemetry_data = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for telemetry using the storage
   */
  nlohmann::json to_json() const {
    return { { "telemetry_data", telemetry_data } };
  }

  /**
   * @brief   Get the message name: telemetry
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "telemetry";
  }
};
/**
 * @brief   Storage class for front_controller_pedal_data CAN message
 */
struct front_controller_pedal_data {
  uint32_t percentage;   /**< CAN signal 'percentage' defined in *.yaml */
  uint8_t brake_enabled; /**< CAN signal 'brake_enabled' defined in *.yaml */

  /**
   * @brief   Decode new CAN data and update the storage for front_controller_pedal_data
   * @param   data Pointer to the CAN message to be decoded
   */
  void decode(const uint8_t *data) {
    uint64_t raw_val = 0U;
    uint8_t start_byte = 0U;
    {
      raw_val = 0U;
      start_byte = 0;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 1]) << 8U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 2]) << 16U;
      raw_val |= static_cast<uint64_t>(data[start_byte + 3]) << 24U;

      percentage = raw_val;
    }
    {
      raw_val = 0U;
      start_byte = 4;
      raw_val |= static_cast<uint64_t>(data[start_byte + 0]) << 0U;

      brake_enabled = raw_val;
    }
  }

  /**
   * @brief   Create a JSON object for front_controller_pedal_data using the storage
   */
  nlohmann::json to_json() const {
    return { { "percentage", percentage }, { "brake_enabled", brake_enabled } };
  }

  /**
   * @brief   Get the message name: front_controller_pedal_data
   * @return  Returns the message name
   */
  std::string get_message_name() const {
    return "front_controller_pedal_data";
  }
};

/**
 * @brief   Main CAN message Handler
 * @details This function shall dynamically allocate a struct based on the CAN ID
 *          This function shall decode the data, then update the CAN Cache 'm_canInfo' with JSON data
 * @param   id Can message ID
 * @param   data Pointer to the CAN message data
 */
void CanListener::canMessageHandler(uint32_t id, const uint8_t *data) {
  switch (id) {
    case SYSTEM_CAN_MESSAGE_REAR_CONTROLLER_TEST_DATA: {
      test_data *message = new test_data();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    case SYSTEM_CAN_MESSAGE_IMU_GYRO_DATA: {
      gyro_data *message = new gyro_data();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    case SYSTEM_CAN_MESSAGE_IMU_ACCEL_DATA: {
      accel_data *message = new accel_data();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    case SYSTEM_CAN_MESSAGE_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG: {
      fast_one_shot_msg *message = new fast_one_shot_msg();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    case SYSTEM_CAN_MESSAGE_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG: {
      medium_one_shot_msg *message = new medium_one_shot_msg();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    case SYSTEM_CAN_MESSAGE_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG: {
      slow_one_shot_msg *message = new slow_one_shot_msg();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    case SYSTEM_CAN_MESSAGE_STEERING_STEERING_STATE: {
      steering_state *message = new steering_state();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    case SYSTEM_CAN_MESSAGE_TELEMETRY_TELEMETRY: {
      telemetry *message = new telemetry();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    case SYSTEM_CAN_MESSAGE_FRONT_CONTROLLER_FRONT_CONTROLLER_PEDAL_DATA: {
      front_controller_pedal_data *message = new front_controller_pedal_data();
      message->decode(data);
      m_canInfo[message->get_message_name()] = message->to_json();
      break;
    }
    default: {
      std::cout << "Unknown message ID: " << static_cast<int>(id) << std::endl;
    }
  }
}
