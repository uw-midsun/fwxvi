#pragma once

/************************************************************************************************
 * @file   can_scheduler.h
 *
 * @brief  Header file defining the CanScheduler class
 *
 * @date   2025-01-04
 * @author Aryan Kashem
 ************************************************************************************************/

/** @warning  This file is autogenerated */

/* Standard library Headers */
#include <atomic>
#include <cstdint>
#include <string>

/* Inter-component Headers */
#include <arpa/inet.h>
#include <fcntl.h>
#include <linux/can.h>
#include <linux/can/bcm.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

/* Intra-component Headers */

/**
 * @defgroup CanScheduler
 * @brief    SocketCAN Broadcast Manager abstraction class
 * @{
 */

#define NUM_FAST_CYCLE_MESSAGES 1U   /**< Number of fast cycle messages */
#define NUM_MEDIUM_CYCLE_MESSAGES 6U /**< Number of medium cycle messages */
#define NUM_SLOW_CYCLE_MESSAGES 2U   /**< Number of slow cycle messages */

/**
 * @brief   Fast cycle Broadcast Manager message for the Linux Kernel
 */
struct {
  struct can_frame frame[NUM_FAST_CYCLE_MESSAGES]; /**< CAN message frames that shall be scheduled for fast cycle */
  struct bcm_msg_head msg_head;                    /**< Broadcast Manager message head containing metadata */
} canFastCycleBCM;

/**
 * @brief   Medium cycle Broadcast Manager message for the Linux Kernel
 */
struct {
  struct can_frame frame[NUM_MEDIUM_CYCLE_MESSAGES]; /**< CAN message frames that shall be scheduled for medium cycle */
  struct bcm_msg_head msg_head;                      /**< Broadcast Manager message head containing metadata */
} canMediumCycleBCM;

/**
 * @brief   Slow cycle Broadcast Manager message for the Linux Kernel
 */
struct {
  struct can_frame frame[NUM_SLOW_CYCLE_MESSAGES]; /**< CAN message frames that shall be scheduled for slow cycle */
  struct bcm_msg_head msg_head;                    /**< Broadcast Manager message head containing metadata */
} canSlowCycleBCM;

/**
 * @class   CanScheduler
 * @brief   Class that handles message scheduling over a SocketCAN interface
 * @details This class is responsible scheduling CAN messages based on their cycle speed
 *          Only 3 cycle speeds are supported, Fast (1kHz), medium (10Hz) and slow (1Hz)
 *          The class shall support message updating during run-time for further bus simulation
 */
class CanScheduler {
 private:
  const std::string CAN_INTERFACE_NAME = "vcan0"; /**< SocketCAN interface name */

  static const constexpr unsigned int FAST_CYCLE_SPEED_MS = 1U;     /**< CAN fast cycle period in milliseconds */
  static const constexpr unsigned int MEDIUM_CYCLE_SPEED_MS = 100U; /**< CAN medium cycle period in milliseconds */
  static const constexpr unsigned int SLOW_CYCLE_SPEED_MS = 1000U;  /**< CAN slow cycle period in milliseconds */

  static const constexpr unsigned int SLOW_CYCLE_BCM_ID = 0U;   /**< Linux Broadcast Manager Id for tracking fast cycle messages */
  static const constexpr unsigned int MEDIUM_CYCLE_BCM_ID = 1U; /**< Linux Broadcast Manager Id for tracking medium cycle messages */
  static const constexpr unsigned int FAST_CYCLE_BCM_ID = 2U;   /**< Linux Broadcast Manager Id for tracking slow cycle messages */

  static const constexpr unsigned int NUM_TOTAL_MESSAGES = 9U; /**< Total number of messages */
  static const constexpr unsigned int MAX_MESSAGE_LENGTH = 8U; /**< Max message length in bytes */

  static const constexpr unsigned int FAST_CAN_COMMUNICATION_FAST_ONE_SHOT_MSG_FRAME_INDEX = 0U; /**< Broadcast Manager fast_one_shot_msg to Frame index mapping */

  static const constexpr unsigned int MEDIUM_REAR_CONTROLLER_TEST_DATA_FRAME_INDEX = 0U;                    /**< Broadcast Manager test_data to Frame index mapping */
  static const constexpr unsigned int MEDIUM_IMU_GYRO_DATA_FRAME_INDEX = 1U;                                /**< Broadcast Manager gyro_data to Frame index mapping */
  static const constexpr unsigned int MEDIUM_IMU_ACCEL_DATA_FRAME_INDEX = 2U;                               /**< Broadcast Manager accel_data to Frame index mapping */
  static const constexpr unsigned int MEDIUM_CAN_COMMUNICATION_MEDIUM_ONE_SHOT_MSG_FRAME_INDEX = 3U;        /**< Broadcast Manager medium_one_shot_msg to Frame index mapping */
  static const constexpr unsigned int MEDIUM_STEERING_STEERING_STATE_FRAME_INDEX = 4U;                      /**< Broadcast Manager steering_state to Frame index mapping */
  static const constexpr unsigned int MEDIUM_FRONT_CONTROLLER_FRONT_CONTROLLER_PEDAL_DATA_FRAME_INDEX = 5U; /**< Broadcast Manager front_controller_pedal_data to Frame index mapping */

  static const constexpr unsigned int SLOW_CAN_COMMUNICATION_SLOW_ONE_SHOT_MSG_FRAME_INDEX = 0U; /**< Broadcast Manager slow_one_shot_msg to Frame index mapping */
  static const constexpr unsigned int SLOW_TELEMETRY_TELEMETRY_FRAME_INDEX = 1U;                 /**< Broadcast Manager telemetry to Frame index mapping */

  int m_bcmCanSocket;              /**< The CAN schedulers Broadcast Manager socket FD */
  std::atomic<bool> m_isConnected; /**< Boolean flag to track the CAN schedulers connection status */

  /**
   * @brief   Schedules all CAN data by updating the Broacast Manager socket
   * @details This function is called by startCanScheduler
   *          This function shall initialize all CAN message values to 0
   */
  void scheduleCanMessages();

 public:
  /**
   * @brief   Constructs a CanScheduler object
   * @details Initializes the CanScheduler. The constructor sets up internal variables
   */
  CanScheduler();

  /**
   * @brief   Starts the CAN scheduler and sets all messages to 0. Must only be called once
   * @details This function will connect to the Linux Broadcast Manager
   *          This function must only be called once, and it will set all messages to 0
   */
  void startCanScheduler();
  /**
   * @brief   Update the CAN value for test_data fault
   * @param   fault_value New value for the signal
   */
  void update_test_data_fault(uint16_t fault_value);
  /**
   * @brief   Update the CAN value for test_data fault_val
   * @param   fault_val_value New value for the signal
   */
  void update_test_data_fault_val(uint16_t fault_val_value);
  /**
   * @brief   Update the CAN value for test_data aux_batt_v
   * @param   aux_batt_v_value New value for the signal
   */
  void update_test_data_aux_batt_v(uint16_t aux_batt_v_value);
  /**
   * @brief   Update the CAN value for test_data afe_status
   * @param   afe_status_value New value for the signal
   */
  void update_test_data_afe_status(uint8_t afe_status_value);
  /**
   * @brief   Update the CAN value for gyro_data x_axis
   * @param   x_axis_value New value for the signal
   */
  void update_gyro_data_x_axis(uint16_t x_axis_value);
  /**
   * @brief   Update the CAN value for gyro_data y_axis
   * @param   y_axis_value New value for the signal
   */
  void update_gyro_data_y_axis(uint16_t y_axis_value);
  /**
   * @brief   Update the CAN value for gyro_data z_axis
   * @param   z_axis_value New value for the signal
   */
  void update_gyro_data_z_axis(uint16_t z_axis_value);
  /**
   * @brief   Update the CAN value for accel_data x_axis
   * @param   x_axis_value New value for the signal
   */
  void update_accel_data_x_axis(uint16_t x_axis_value);
  /**
   * @brief   Update the CAN value for accel_data y_axis
   * @param   y_axis_value New value for the signal
   */
  void update_accel_data_y_axis(uint16_t y_axis_value);
  /**
   * @brief   Update the CAN value for accel_data z_axis
   * @param   z_axis_value New value for the signal
   */
  void update_accel_data_z_axis(uint16_t z_axis_value);
  /**
   * @brief   Update the CAN value for fast_one_shot_msg sig1
   * @param   sig1_value New value for the signal
   */
  void update_fast_one_shot_msg_sig1(uint16_t sig1_value);
  /**
   * @brief   Update the CAN value for fast_one_shot_msg sig2
   * @param   sig2_value New value for the signal
   */
  void update_fast_one_shot_msg_sig2(uint16_t sig2_value);
  /**
   * @brief   Update the CAN value for medium_one_shot_msg sig1
   * @param   sig1_value New value for the signal
   */
  void update_medium_one_shot_msg_sig1(uint16_t sig1_value);
  /**
   * @brief   Update the CAN value for medium_one_shot_msg sig2
   * @param   sig2_value New value for the signal
   */
  void update_medium_one_shot_msg_sig2(uint16_t sig2_value);
  /**
   * @brief   Update the CAN value for slow_one_shot_msg sig1
   * @param   sig1_value New value for the signal
   */
  void update_slow_one_shot_msg_sig1(uint16_t sig1_value);
  /**
   * @brief   Update the CAN value for slow_one_shot_msg sig2
   * @param   sig2_value New value for the signal
   */
  void update_slow_one_shot_msg_sig2(uint16_t sig2_value);
  /**
   * @brief   Update the CAN value for steering_state target_velocity
   * @param   target_velocity_value New value for the signal
   */
  void update_steering_state_target_velocity(uint32_t target_velocity_value);
  /**
   * @brief   Update the CAN value for steering_state drive_state
   * @param   drive_state_value New value for the signal
   */
  void update_steering_state_drive_state(uint8_t drive_state_value);
  /**
   * @brief   Update the CAN value for steering_state cruise_control
   * @param   cruise_control_value New value for the signal
   */
  void update_steering_state_cruise_control(uint8_t cruise_control_value);
  /**
   * @brief   Update the CAN value for steering_state regen_braking
   * @param   regen_braking_value New value for the signal
   */
  void update_steering_state_regen_braking(uint8_t regen_braking_value);
  /**
   * @brief   Update the CAN value for steering_state hazard_enabled
   * @param   hazard_enabled_value New value for the signal
   */
  void update_steering_state_hazard_enabled(uint8_t hazard_enabled_value);
  /**
   * @brief   Update the CAN value for telemetry telemetry_data
   * @param   telemetry_data_value New value for the signal
   */
  void update_telemetry_telemetry_data(uint64_t telemetry_data_value);
  /**
   * @brief   Update the CAN value for front_controller_pedal_data percentage
   * @param   percentage_value New value for the signal
   */
  void update_front_controller_pedal_data_percentage(uint32_t percentage_value);
  /**
   * @brief   Update the CAN value for front_controller_pedal_data brake_enabled
   * @param   brake_enabled_value New value for the signal
   */
  void update_front_controller_pedal_data_brake_enabled(uint8_t brake_enabled_value);
};

/** @} */
